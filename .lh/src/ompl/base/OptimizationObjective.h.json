{
    "sourceFile": "src/ompl/base/OptimizationObjective.h",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1684418668627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1684418676092,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -108,10 +108,10 @@\n \n             /** \\brief Return the minimum cost given \\e c1 and \\e c2. Uses isCostBetterThan. */\n             virtual Cost betterCost(Cost c1, Cost c2) const;\n \n-            /** \\brief Return the minimum cost given \\e c1 and \\e c2. Uses isCostBetterThan. */\n-            virtual Cost betterCost(Cost c1, Cost c2) const;\n+            /** \\brief Return the maximum cost given \\e c1 and \\e c2. Uses isCostBetterThan. */\n+            virtual Cost worseCost(Cost c1, Cost c2) const;\n \n             /** \\brief Evaluate a cost map defined on the state space at a state \\e s. */\n             virtual Cost stateCost(const State *s) const = 0;\n \n"
                }
            ],
            "date": 1684418668627,
            "name": "Commit-0",
            "content": "/*********************************************************************\n* Software License Agreement (BSD License)\n*\n*  Copyright (c) 2012, Willow Garage, Inc.\n*  All rights reserved.\n*\n*  Redistribution and use in source and binary forms, with or without\n*  modification, are permitted provided that the following conditions\n*  are met:\n*\n*   * Redistributions of source code must retain the above copyright\n*     notice, this list of conditions and the following disclaimer.\n*   * Redistributions in binary form must reproduce the above\n*     copyright notice, this list of conditions and the following\n*     disclaimer in the documentation and/or other materials provided\n*     with the distribution.\n*   * Neither the name of the Willow Garage nor the names of its\n*     contributors may be used to endorse or promote products derived\n*     from this software without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*********************************************************************/\n\n/* Author: Luis G. Torres, Ioan Sucan, Jonathan Gammell */\n\n#ifndef OMPL_BASE_OPTIMIZATION_OBJECTIVE_\n#define OMPL_BASE_OPTIMIZATION_OBJECTIVE_\n\n#include \"ompl/base/Cost.h\"\n#include \"ompl/base/SpaceInformation.h\"\n#include \"ompl/util/ClassForward.h\"\n#include \"ompl/base/ProblemDefinition.h\"\n#include \"ompl/base/samplers/InformedStateSampler.h\"\n\n#include <functional>\n#include <iostream>\n\nnamespace ompl\n{\n    namespace base\n    {\n        class Goal;\n\n        /** \\brief The definition of a function which returns an admissible estimate of the optimal path cost from a\n         * given state to a goal. */\n        using CostToGoHeuristic = std::function<Cost(const State *, const Goal *)>;\n\n        /// @cond IGNORE\n        /** \\brief Forward declaration of ompl::base::OptimizationObjective */\n        OMPL_CLASS_FORWARD(OptimizationObjective);\n        /// @endcond\n\n        /** \\class ompl::base::OptimizationObjectivePtr\n            \\brief A shared pointer wrapper for ompl::base::OptimizationObjective */\n\n        /** \\brief Abstract definition of optimization objectives.\n\n            \\note This implementation has greatly benefited from discussions with Kris Hauser */\n        class OptimizationObjective\n        {\n        public:\n            // non-copyable\n            OptimizationObjective(const OptimizationObjective &) = delete;\n            OptimizationObjective &operator=(const OptimizationObjective &) = delete;\n\n            /** \\brief Constructor. The objective must always know the space information it is part of. The cost\n             * threshold for objective satisfaction defaults to 0.0. */\n            OptimizationObjective(SpaceInformationPtr si);\n\n            virtual ~OptimizationObjective() = default;\n\n            /** \\brief Get the description of this optimization objective */\n            const std::string &getDescription() const;\n\n            /** \\brief Check if the the given cost \\e c satisfies the specified cost objective, defined as \\e better \\e\n             * than the specified threshold. */\n            virtual bool isSatisfied(Cost c) const;\n\n            /** \\brief Returns the cost threshold currently being checked for objective satisfaction */\n            Cost getCostThreshold() const;\n\n            /** \\brief Set the cost threshold for objective satisfaction. When a path is found with a cost better than\n             * the cost threshold, the objective is considered satisfied. */\n            void setCostThreshold(Cost c);\n\n            /** \\brief Check whether the the cost \\e c1 is considered better than the cost \\e c2. By default, this\n             * returns true if if c1 is less than c2. */\n            virtual bool isCostBetterThan(Cost c1, Cost c2) const;\n\n            /** \\brief Compare whether cost \\e c1 and cost \\e c2 are equivalent. By default defined as\n             * !isCostBetterThan(c1, c2) && !isCostBetterThan(c2, c1), as if c1 is not better than c2, and c2 is not\n             * better than c1, then they are equal. */\n            virtual bool isCostEquivalentTo(Cost c1, Cost c2) const;\n\n            /** \\brief Returns whether the cost is finite or not. */\n            virtual bool isFinite(Cost cost) const;\n\n            /** \\brief Return the minimum cost given \\e c1 and \\e c2. Uses isCostBetterThan. */\n            virtual Cost betterCost(Cost c1, Cost c2) const;\n\n            /** \\brief Return the minimum cost given \\e c1 and \\e c2. Uses isCostBetterThan. */\n            virtual Cost betterCost(Cost c1, Cost c2) const;\n\n            /** \\brief Evaluate a cost map defined on the state space at a state \\e s. */\n            virtual Cost stateCost(const State *s) const = 0;\n\n            /** \\brief Get the cost that corresponds to the motion segment between \\e s1 and \\e s2 */\n            virtual Cost motionCost(const State *s1, const State *s2) const = 0;\n\n            /** \\brief Get the cost that corresponds to combining the costs \\e c1 and \\e c2. Default implementation\n             * defines this combination as an addition. */\n            virtual Cost combineCosts(Cost c1, Cost c2) const;\n\n            /** \\brief Get the identity cost value. The identity cost value is the cost c_i such that, for all costs c,\n             * combineCosts(c, c_i) = combineCosts(c_i, c) = c. In other words, combining a cost with the identity cost\n             * does not change the original cost. By default, a cost with the value 0.0 is returned. It's very important\n             * to override this with the proper identity value for your optimization objectives, or else optimal\n             * planners may not work. */\n            virtual Cost identityCost() const;\n\n            /** \\brief Get a cost which is greater than all other costs in this OptimizationObjective; required for use\n             * in Dijkstra/Astar. Defaults to returning the double value inf.*/\n            virtual Cost infiniteCost() const;\n\n            /** \\brief Returns a cost value corresponding to starting at a state \\e s. No optimal planners currently\n             * support this method. Defaults to returning the objective's identity cost. */\n            virtual Cost initialCost(const State *s) const;\n\n            /** \\brief Returns a cost value corresponding to a path ending at a state \\e s. No optimal planners\n             * currently support this method. Defaults to returning the objective's identity cost. */\n            virtual Cost terminalCost(const State *s) const;\n\n            /** \\brief Check if this objective has a symmetric cost metric, i.e. motionCost(s1, s2) = motionCost(s2,\n             * s1). Default implementation returns whether the underlying state space has symmetric interpolation. */\n            virtual bool isSymmetric() const;\n\n            /** \\brief Compute the average state cost of this objective by taking a sample of \\e numStates states */\n            virtual Cost averageStateCost(unsigned int numStates) const;\n\n            /** \\brief Set the cost-to-go heuristic function for this objective. The cost-to-go heuristic is a function\n             * which returns an admissible estimate of the optimal path cost from a given state to a goal, where\n             * \"admissible\" means that the estimated cost is always less than the true optimal cost. */\n            void setCostToGoHeuristic(const CostToGoHeuristic &costToGo);\n\n            /** \\brief Check if this objective has a cost-to-go heuristic function. */\n            bool hasCostToGoHeuristic() const;\n\n            /** \\brief Uses a cost-to-go heuristic to calculate an admissible estimate of the optimal cost from a given\n             * state to a given goal. If no cost-to-go heuristic has been specified with setCostToGoHeuristic(), this\n             * function just returns the identity cost, which is sure to be an admissible heuristic if there are no\n             * negative costs. */\n            Cost costToGo(const State *state, const Goal *goal) const;\n\n            /** \\brief Defines an admissible estimate on the optimal cost on the motion between states \\e s1 and \\e s2.\n             * An admissible estimate always undervalues the true optimal cost of the motion. Used by some planners to\n             * speed up planning. The default implementation of this method returns this objective's identity cost,\n             * which is sure to be an admissible heuristic if there are no negative costs. */\n            virtual Cost motionCostHeuristic(const State *s1, const State *s2) const;\n\n            /** \\brief Returns this objective's SpaceInformation. Needed for operators in MultiOptimizationObjective */\n            const SpaceInformationPtr &getSpaceInformation() const;\n\n            /** \\brief Allocate a heuristic-sampling state generator for this cost function, defaults to a basic\n             * rejection sampling scheme when the derived class does not provide a better method.*/\n            virtual InformedSamplerPtr allocInformedStateSampler(const ProblemDefinitionPtr &probDefn,\n                                                                 unsigned int maxNumberCalls) const;\n\n            /** \\brief Print information about this optimization objective */\n            virtual void print(std::ostream &out) const;\n\n        protected:\n            /** \\brief The space information for this objective */\n            SpaceInformationPtr si_;\n\n            /** \\brief The description of this optimization objective */\n            std::string description_;\n\n            /** \\brief The cost threshold used for checking whether this objective has been satisfied during planning */\n            Cost threshold_;\n\n            /** \\brief The function used for returning admissible estimates on the optimal cost of the path between a\n             * given state and goal */\n            CostToGoHeuristic costToGoFn_;\n        };\n\n        /**\n            \\brief For use when the cost-to-go of a state under the\n            optimization objective is equivalent to the\n            goal region's distanceGoal() . This function assumes that all states\n            within the goal region's threshold have a cost-to-go of\n            exactly zero. Note: \\e goal is assumed to be of type\n            ompl::base::GoalRegion\n        */\n        Cost goalRegionCostToGo(const State *state, const Goal *goal);\n\n        /** \\brief This class allows for the definition of multiobjective optimal planning problems. Objectives are\n         * added to this compound object, and motion costs are computed by taking a weighted sum of the individual\n         * objective costs. */\n        class MultiOptimizationObjective : public OptimizationObjective\n        {\n        public:\n            MultiOptimizationObjective(const SpaceInformationPtr &si);\n\n            /** \\brief Adds a new objective for this multiobjective. A weight must also be specified for specifying\n             * importance of this objective in planning. */\n            void addObjective(const OptimizationObjectivePtr &objective, double weight);\n\n            /** \\brief Returns the number of objectives that make up this multiobjective. */\n            std::size_t getObjectiveCount() const;\n\n            /** \\brief Returns a specific objective from this multiobjective, where the individual objectives are in\n             * order of addition to the multiobjective, and \\e idx is the zero-based index into this ordering. */\n            const OptimizationObjectivePtr &getObjective(unsigned int idx) const;\n\n            /** \\brief Returns the weighing factor of a specific objective */\n            double getObjectiveWeight(unsigned int idx) const;\n\n            /** \\brief Sets the weighing factor of a specific objective */\n            void setObjectiveWeight(unsigned int idx, double weight);\n\n            /** \\brief This method \"freezes\" this multiobjective so that no more objectives can be added to it */\n            void lock();\n\n            /** \\brief Returns whether this multiobjective has been locked from adding further objectives */\n            bool isLocked() const;\n\n            /** The default implementation of this method is to use\n              addition to add up all the individual objectives' state cost\n              values, where each individual value is scaled by its\n              weight */\n            Cost stateCost(const State *s) const override;\n\n            /** The default implementation of this method is to use\n              addition to add up all the individual objectives' motion\n              cost values, where each individual value is scaled by\n              its weight */\n            Cost motionCost(const State *s1, const State *s2) const override;\n\n        protected:\n            /** \\brief Defines a pairing of an objective and its weight */\n            struct Component\n            {\n                Component(OptimizationObjectivePtr obj, double weight);\n                OptimizationObjectivePtr objective;\n                double weight;\n            };\n\n            /** \\brief List of objective/weight pairs */\n            std::vector<Component> components_;\n\n            /** \\brief Whether this multiobjective is locked from further additions */\n            bool locked_;\n\n\n            // Friend functions for operator overloads for easy multiobjective creation\n            friend OptimizationObjectivePtr operator+(const OptimizationObjectivePtr &a,\n                                                      const OptimizationObjectivePtr &b);\n\n            friend OptimizationObjectivePtr operator*(double weight, const OptimizationObjectivePtr &a);\n\n            friend OptimizationObjectivePtr operator*(const OptimizationObjectivePtr &a, double weight);\n        };\n\n        /** \\brief Given two optimization objectives, returns a MultiOptimizationObjective that combines the two\n          * objectives with both weights equal to 1.0. */\n        OptimizationObjectivePtr operator+(const OptimizationObjectivePtr &a,\n                                                  const OptimizationObjectivePtr &b);\n\n        /** \\brief Given a weighing factor and an optimization objective, returns a MultiOptimizationObjective\n          * containing only this objective weighted by the given weight */\n        OptimizationObjectivePtr operator*(double weight, const OptimizationObjectivePtr &a);\n\n        /** \\brief Given a weighing factor and an optimization objective, returns a MultiOptimizationObjective\n         * containing only this objective weighted by the given weight */\n        OptimizationObjectivePtr operator*(const OptimizationObjectivePtr &a, double weight);\n    }\n}\n\n#endif\n"
        }
    ]
}