{
    "sourceFile": "src/ompl/base/src/ProblemDefinition.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1684419034495,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1684419040455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -425,9 +425,9 @@\n                                                     const std::string &plannerName) const\n {\n     PlannerSolution sol(path);\n     if (computeSolutionCost_) {\n-        Cost sol_cost {path->cost(optimizationObjective_, use_worst_)};\n+        Cost sol_cost {path->cost(optimizationObjective_, use_worst_motion_cost_in_o)};\n         sol.setOptimized(optimizationObjective_, sol_cost, false);\n     }\n     if (approximate && !acceptApproximate_)\n         return;\n"
                },
                {
                    "date": 1684419047044,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -425,9 +425,9 @@\n                                                     const std::string &plannerName) const\n {\n     PlannerSolution sol(path);\n     if (computeSolutionCost_) {\n-        Cost sol_cost {path->cost(optimizationObjective_, use_worst_motion_cost_in_o)};\n+        Cost sol_cost {path->cost(optimizationObjective_, use_worst_motion_cost_in_path_)};\n         sol.setOptimized(optimizationObjective_, sol_cost, false);\n     }\n     if (approximate && !acceptApproximate_)\n         return;\n"
                }
            ],
            "date": 1684419034495,
            "name": "Commit-0",
            "content": "/*********************************************************************\n* Software License Agreement (BSD License)\n*\n*  Copyright (c) 2010, Rice University\n*  All rights reserved.\n*\n*  Redistribution and use in source and binary forms, with or without\n*  modification, are permitted provided that the following conditions\n*  are met:\n*\n*   * Redistributions of source code must retain the above copyright\n*     notice, this list of conditions and the following disclaimer.\n*   * Redistributions in binary form must reproduce the above\n*     copyright notice, this list of conditions and the following\n*     disclaimer in the documentation and/or other materials provided\n*     with the distribution.\n*   * Neither the name of the Rice University nor the names of its\n*     contributors may be used to endorse or promote products derived\n*     from this software without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*********************************************************************/\n\n/* Author: Ioan Sucan */\n\n#include \"ompl/base/ProblemDefinition.h\"\n#include \"ompl/base/goals/GoalState.h\"\n#include \"ompl/base/goals/GoalStates.h\"\n#include \"ompl/base/OptimizationObjective.h\"\n#include \"ompl/control/SpaceInformation.h\"\n#include \"ompl/control/PathControl.h\"\n#include \"ompl/tools/config/MagicConstants.h\"\n#include <sstream>\n#include <algorithm>\n#include <mutex>\n#include <utility>\n\n/// @cond IGNORE\nnamespace ompl\n{\n    namespace base\n    {\n        class ProblemDefinition::PlannerSolutionSet\n        {\n        public:\n            PlannerSolutionSet()\n            = default;\n\n            void add(const PlannerSolution &s)\n            {\n                std::lock_guard<std::mutex> slock(lock_);\n                int index = solutions_.size();\n                solutions_.push_back(s);\n                solutions_.back().index_ = index;\n                std::sort(solutions_.begin(), solutions_.end());\n            }\n\n            void clear()\n            {\n                std::lock_guard<std::mutex> slock(lock_);\n                solutions_.clear();\n            }\n\n            std::vector<PlannerSolution> getSolutions()\n            {\n                std::lock_guard<std::mutex> slock(lock_);\n                std::vector<PlannerSolution> copy = solutions_;\n                return copy;\n            }\n\n            bool isApproximate()\n            {\n                std::lock_guard<std::mutex> slock(lock_);\n                bool result = false;\n                if (!solutions_.empty())\n                    result = solutions_[0].approximate_;\n                return result;\n            }\n\n            bool isOptimized()\n            {\n                std::lock_guard<std::mutex> slock(lock_);\n                bool result = false;\n                if (!solutions_.empty())\n                    result = solutions_[0].optimized_;\n                return result;\n            }\n\n            double getDifference()\n            {\n                std::lock_guard<std::mutex> slock(lock_);\n                double diff = -1.0;\n                if (!solutions_.empty())\n                    diff = solutions_[0].difference_;\n                return diff;\n            }\n\n            PathPtr getTopSolution()\n            {\n                std::lock_guard<std::mutex> slock(lock_);\n                PathPtr copy;\n                if (!solutions_.empty())\n                    copy = solutions_[0].path_;\n                return copy;\n            }\n\n            bool getTopSolution(PlannerSolution &solution)\n            {\n                std::lock_guard<std::mutex> slock(lock_);\n\n                if (!solutions_.empty())\n                {\n                    solution = solutions_[0];\n                    return true;\n                }\n                else\n                {\n                    return false;\n                }\n            }\n\n            std::size_t getSolutionCount()\n            {\n                std::lock_guard<std::mutex> slock(lock_);\n                std::size_t result = solutions_.size();\n                return result;\n            }\n\n        private:\n            std::vector<PlannerSolution> solutions_;\n            std::mutex lock_;\n        };\n    }\n}\n/// @endcond\n\nbool ompl::base::PlannerSolution::operator<(const PlannerSolution &b) const\n{\n    if (!approximate_ && b.approximate_)\n        return true;\n    if (approximate_ && !b.approximate_)\n        return false;\n    if (approximate_ && b.approximate_)\n        return difference_ < b.difference_;\n    if (optimized_ && !b.optimized_)\n        return true;\n    if (!optimized_ && b.optimized_)\n        return false;\n    return opt_ ? opt_->isCostBetterThan(cost_, b.cost_) : length_ < b.length_;\n}\n\nompl::base::ProblemDefinition::ProblemDefinition(SpaceInformationPtr si)\n  : si_(std::move(si)), solutions_(std::make_shared<PlannerSolutionSet>())\n{\n}\n\nompl::base::ProblemDefinitionPtr ompl::base::ProblemDefinition::clone() const\n{\n    auto result = std::make_shared<ProblemDefinition>(si_);\n    result->startStates_.reserve(startStates_.size());\n    for (const auto &state : startStates_)\n        result->addStartState(state);\n    result->setGoal(goal_);\n    result->setOptimizationObjective(optimizationObjective_);\n    result->setSolutionNonExistenceProof(nonExistenceProof_);\n\n    return result;\n}\n\nvoid ompl::base::ProblemDefinition::setStartAndGoalStates(const State *start, const State *goal, const double threshold)\n{\n    clearStartStates();\n    addStartState(start);\n    setGoalState(goal, threshold);\n}\n\nvoid ompl::base::ProblemDefinition::setGoalState(const State *goal, const double threshold)\n{\n    clearGoal();\n    auto gs(std::make_shared<GoalState>(si_));\n    gs->setState(goal);\n    gs->setThreshold(threshold);\n    setGoal(gs);\n}\n\nbool ompl::base::ProblemDefinition::hasStartState(const State *state, unsigned int *startIndex) const\n{\n    for (unsigned int i = 0; i < startStates_.size(); ++i)\n        if (si_->equalStates(state, startStates_[i]))\n        {\n            if (startIndex)\n                *startIndex = i;\n            return true;\n        }\n    return false;\n}\n\nbool ompl::base::ProblemDefinition::fixInvalidInputState(State *state, double dist, bool start, unsigned int attempts)\n{\n    bool result = false;\n\n    bool b = si_->satisfiesBounds(state);\n    bool v = false;\n    if (b)\n    {\n        v = si_->isValid(state);\n        if (!v)\n            OMPL_DEBUG(\"%s state is not valid\", start ? \"Start\" : \"Goal\");\n    }\n    else\n        OMPL_DEBUG(\"%s state is not within space bounds\", start ? \"Start\" : \"Goal\");\n\n    if (!b || !v)\n    {\n        std::stringstream ss;\n        si_->printState(state, ss);\n        ss << \" within distance \" << dist;\n        OMPL_DEBUG(\"Attempting to fix %s state %s\", start ? \"start\" : \"goal\", ss.str().c_str());\n\n        State *temp = si_->allocState();\n        if (si_->searchValidNearby(temp, state, dist, attempts))\n        {\n            si_->copyState(state, temp);\n            result = true;\n        }\n        else\n            OMPL_WARN(\"Unable to fix %s state\", start ? \"start\" : \"goal\");\n        si_->freeState(temp);\n    }\n\n    return result;\n}\n\nbool ompl::base::ProblemDefinition::fixInvalidInputStates(double distStart, double distGoal, unsigned int attempts)\n{\n    bool result = true;\n\n    // fix start states\n    for (auto &startState : startStates_)\n        if (!fixInvalidInputState(startState, distStart, true, attempts))\n            result = false;\n\n    // fix goal state\n    auto *goal = dynamic_cast<GoalState *>(goal_.get());\n    if (goal)\n    {\n        if (!fixInvalidInputState(const_cast<State *>(goal->getState()), distGoal, false, attempts))\n            result = false;\n    }\n\n    // fix goal state\n    auto *goals = dynamic_cast<GoalStates *>(goal_.get());\n    if (goals)\n    {\n        for (unsigned int i = 0; i < goals->getStateCount(); ++i)\n            if (!fixInvalidInputState(const_cast<State *>(goals->getState(i)), distGoal, false, attempts))\n                result = false;\n    }\n\n    return result;\n}\n\nvoid ompl::base::ProblemDefinition::getInputStates(std::vector<const State *> &states) const\n{\n    states.clear();\n    for (auto startState : startStates_)\n        states.push_back(startState);\n\n    auto *goal = dynamic_cast<GoalState *>(goal_.get());\n    if (goal)\n        states.push_back(goal->getState());\n\n    auto *goals = dynamic_cast<GoalStates *>(goal_.get());\n    if (goals)\n        for (unsigned int i = 0; i < goals->getStateCount(); ++i)\n            states.push_back(goals->getState(i));\n}\n\nompl::base::PathPtr ompl::base::ProblemDefinition::isStraightLinePathValid() const\n{\n    PathPtr path;\n    if (control::SpaceInformationPtr sic = std::dynamic_pointer_cast<control::SpaceInformation, SpaceInformation>(si_))\n    {\n        unsigned int startIndex;\n        if (isTrivial(&startIndex, nullptr))\n        {\n            auto pc(std::make_shared<control::PathControl>(sic));\n            pc->append(startStates_[startIndex]);\n            control::Control *null = sic->allocControl();\n            sic->nullControl(null);\n            pc->append(startStates_[startIndex], null, 0.0);\n            sic->freeControl(null);\n            path = pc;\n        }\n        else\n        {\n            control::Control *nc = sic->allocControl();\n            State *result1 = sic->allocState();\n            State *result2 = sic->allocState();\n            sic->nullControl(nc);\n\n            for (unsigned int k = 0; k < startStates_.size() && !path; ++k)\n            {\n                const State *start = startStates_[k];\n                if (start && si_->isValid(start) && si_->satisfiesBounds(start))\n                {\n                    sic->copyState(result1, start);\n                    for (unsigned int i = 0; i < sic->getMaxControlDuration() && !path; ++i)\n                        if (sic->propagateWhileValid(result1, nc, 1, result2))\n                        {\n                            if (goal_->isSatisfied(result2))\n                            {\n                                auto pc(std::make_shared<control::PathControl>(sic));\n                                pc->append(start);\n                                pc->append(result2, nc, (i + 1) * sic->getPropagationStepSize());\n                                path = pc;\n                                break;\n                            }\n                            std::swap(result1, result2);\n                        }\n                }\n            }\n            sic->freeState(result1);\n            sic->freeState(result2);\n            sic->freeControl(nc);\n        }\n    }\n    else\n    {\n        std::vector<const State *> states;\n        auto *goal = dynamic_cast<GoalState *>(goal_.get());\n        if (goal)\n            if (si_->isValid(goal->getState()) && si_->satisfiesBounds(goal->getState()))\n                states.push_back(goal->getState());\n        auto *goals = dynamic_cast<GoalStates *>(goal_.get());\n        if (goals)\n            for (unsigned int i = 0; i < goals->getStateCount(); ++i)\n                if (si_->isValid(goals->getState(i)) && si_->satisfiesBounds(goals->getState(i)))\n                    states.push_back(goals->getState(i));\n\n        if (states.empty())\n        {\n            unsigned int startIndex;\n            if (isTrivial(&startIndex))\n                path =\n                    std::make_shared<geometric::PathGeometric>(si_, startStates_[startIndex], startStates_[startIndex]);\n        }\n        else\n        {\n            for (const auto start : startStates_)\n                if (start && si_->isValid(start) && si_->satisfiesBounds(start))\n                    for (const auto state : states)\n                        if (si_->checkMotion(start, state))\n                            return std::make_shared<geometric::PathGeometric>(si_, start, state);\n        }\n    }\n\n    return path;\n}\n\nbool ompl::base::ProblemDefinition::isTrivial(unsigned int *startIndex, double *distance) const\n{\n    if (!goal_)\n    {\n        OMPL_ERROR(\"Goal undefined\");\n        return false;\n    }\n\n    for (unsigned int i = 0; i < startStates_.size(); ++i)\n    {\n        const State *start = startStates_[i];\n        if (start && si_->isValid(start) && si_->satisfiesBounds(start))\n        {\n            double dist;\n            if (goal_->isSatisfied(start, &dist))\n            {\n                if (startIndex)\n                    *startIndex = i;\n                if (distance)\n                    *distance = dist;\n                return true;\n            }\n        }\n        else\n        {\n            OMPL_ERROR(\"Initial state is in collision!\");\n        }\n    }\n\n    return false;\n}\n\nbool ompl::base::ProblemDefinition::hasSolution() const\n{\n    return solutions_->getSolutionCount() > 0;\n}\n\nstd::size_t ompl::base::ProblemDefinition::getSolutionCount() const\n{\n    return solutions_->getSolutionCount();\n}\n\nompl::base::PathPtr ompl::base::ProblemDefinition::getSolutionPath() const\n{\n    return solutions_->getTopSolution();\n}\n\nbool ompl::base::ProblemDefinition::getSolution(PlannerSolution &solution) const\n{\n    return solutions_->getTopSolution(solution);\n}\n\nvoid ompl::base::ProblemDefinition::addSolutionPath(const PathPtr &path, bool approximate, double difference,\n                                                    const std::string &plannerName) const\n{\n    PlannerSolution sol(path);\n    if (computeSolutionCost_) {\n        Cost sol_cost {path->cost(optimizationObjective_, use_worst_)};\n        sol.setOptimized(optimizationObjective_, sol_cost, false);\n    }\n    if (approximate && !acceptApproximate_)\n        return;\n    if (approximate)\n        sol.setApproximate(difference);\n    sol.setPlannerName(plannerName);\n    addSolutionPath(sol);\n}\n\nvoid ompl::base::ProblemDefinition::addSolutionPath(const PlannerSolution &sol) const\n{\n    if (sol.approximate_)\n        OMPL_INFORM(\"ProblemDefinition: Adding approximate solution from planner %s\", sol.plannerName_.c_str());\n    solutions_->add(sol);\n}\n\nbool ompl::base::ProblemDefinition::hasApproximateSolution() const\n{\n    return solutions_->isApproximate();\n}\n\nbool ompl::base::ProblemDefinition::hasOptimizedSolution() const\n{\n    return solutions_->isOptimized();\n}\n\ndouble ompl::base::ProblemDefinition::getSolutionDifference() const\n{\n    return solutions_->getDifference();\n}\n\nstd::vector<ompl::base::PlannerSolution> ompl::base::ProblemDefinition::getSolutions() const\n{\n    return solutions_->getSolutions();\n}\n\nvoid ompl::base::ProblemDefinition::clearSolutionPaths() const\n{\n    solutions_->clear();\n}\n\nvoid ompl::base::ProblemDefinition::print(std::ostream &out) const\n{\n    out << \"Start states:\" << std::endl;\n    for (auto startState : startStates_)\n        si_->printState(startState, out);\n    if (goal_)\n        goal_->print(out);\n    else\n        out << \"Goal = nullptr\" << std::endl;\n    if (optimizationObjective_)\n    {\n        optimizationObjective_->print(out);\n        out << \"Average state cost: \" << optimizationObjective_->averageStateCost(magic::TEST_STATE_COUNT) << std::endl;\n    }\n    else\n        out << \"OptimizationObjective = nullptr\" << std::endl;\n    out << \"There are \" << solutions_->getSolutionCount() << \" solutions\" << std::endl;\n}\n\nbool ompl::base::ProblemDefinition::hasSolutionNonExistenceProof() const\n{\n    return nonExistenceProof_.get();\n}\n\nvoid ompl::base::ProblemDefinition::clearSolutionNonExistenceProof()\n{\n    nonExistenceProof_.reset();\n}\n\nconst ompl::base::SolutionNonExistenceProofPtr &ompl::base::ProblemDefinition::getSolutionNonExistenceProof() const\n{\n    return nonExistenceProof_;\n}\n\nvoid ompl::base::ProblemDefinition::setSolutionNonExistenceProof(\n    const ompl::base::SolutionNonExistenceProofPtr &nonExistenceProof)\n{\n    nonExistenceProof_ = nonExistenceProof;\n}\n"
        }
    ]
}