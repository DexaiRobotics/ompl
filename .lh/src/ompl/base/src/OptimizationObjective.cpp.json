{
    "sourceFile": "src/ompl/base/src/OptimizationObjective.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1684418304505,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1684418311689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,11 +88,11 @@\n {\n     return isCostBetterThan(c1, c2) ? c1 : c2;\n }\n \n-ompl::base::Cost ompl::base::OptimizationObjective::betterCost(Cost c1, Cost c2) const\n+ompl::base::Cost ompl::base::OptimizationObjective::worseCost(Cost c1, Cost c2) const\n {\n-    return isCostBetterThan(c1, c2) ? c1 : c2;\n+    return isCostBetterThan(c1, c2) ? c2 : c2;\n }\n \n ompl::base::Cost ompl::base::OptimizationObjective::combineCosts(Cost c1, Cost c2) const\n {\n"
                },
                {
                    "date": 1684418679946,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n }\n \n ompl::base::Cost ompl::base::OptimizationObjective::worseCost(Cost c1, Cost c2) const\n {\n-    return isCostBetterThan(c1, c2) ? c2 : c2;\n+    return isCostBetterThan(c1, c2) ? c2 : c1;\n }\n \n ompl::base::Cost ompl::base::OptimizationObjective::combineCosts(Cost c1, Cost c2) const\n {\n"
                }
            ],
            "date": 1684418304505,
            "name": "Commit-0",
            "content": "/*********************************************************************\n* Software License Agreement (BSD License)\n*\n*  Copyright (c) 2008, Willow Garage, Inc.\n*  All rights reserved.\n*\n*  Redistribution and use in source and binary forms, with or without\n*  modification, are permitted provided that the following conditions\n*  are met:\n*\n*   * Redistributions of source code must retain the above copyright\n*     notice, this list of conditions and the following disclaimer.\n*   * Redistributions in binary form must reproduce the above\n*     copyright notice, this list of conditions and the following\n*     disclaimer in the documentation and/or other materials provided\n*     with the distribution.\n*   * Neither the name of the Willow Garage nor the names of its\n*     contributors may be used to endorse or promote products derived\n*     from this software without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*********************************************************************/\n\n/* Author: Luis G. Torres, Ioan Sucan, Jonathan Gammell */\n\n#include \"ompl/base/OptimizationObjective.h\"\n#include \"ompl/tools/config/MagicConstants.h\"\n#include \"ompl/base/goals/GoalRegion.h\"\n#include \"ompl/base/samplers/informed/RejectionInfSampler.h\"\n#include \"ompl/base/samplers/informed/PathLengthDirectInfSampler.h\"\n#include <limits>\n// For std::make_shared\n#include <memory>\n#include <utility>\n\nompl::base::OptimizationObjective::OptimizationObjective(SpaceInformationPtr si) : si_(std::move(si)), threshold_(0.0)\n{\n}\n\nconst std::string &ompl::base::OptimizationObjective::getDescription() const\n{\n    return description_;\n}\n\nbool ompl::base::OptimizationObjective::isSatisfied(Cost c) const\n{\n    return isCostBetterThan(c, threshold_);\n}\n\nompl::base::Cost ompl::base::OptimizationObjective::getCostThreshold() const\n{\n    return threshold_;\n}\n\nvoid ompl::base::OptimizationObjective::setCostThreshold(Cost c)\n{\n    threshold_ = c;\n}\n\nbool ompl::base::OptimizationObjective::isCostBetterThan(Cost c1, Cost c2) const\n{\n    return c1.value() < c2.value();\n}\n\nbool ompl::base::OptimizationObjective::isCostEquivalentTo(Cost c1, Cost c2) const\n{\n    // If c1 is not better than c2, and c2 is not better than c1, then they are equal\n    return !isCostBetterThan(c1, c2) && !isCostBetterThan(c2, c1);\n}\n\nbool ompl::base::OptimizationObjective::isFinite(Cost cost) const\n{\n    return isCostBetterThan(cost, infiniteCost());\n}\n\nompl::base::Cost ompl::base::OptimizationObjective::betterCost(Cost c1, Cost c2) const\n{\n    return isCostBetterThan(c1, c2) ? c1 : c2;\n}\n\nompl::base::Cost ompl::base::OptimizationObjective::betterCost(Cost c1, Cost c2) const\n{\n    return isCostBetterThan(c1, c2) ? c1 : c2;\n}\n\nompl::base::Cost ompl::base::OptimizationObjective::combineCosts(Cost c1, Cost c2) const\n{\n    return Cost(c1.value() + c2.value());\n}\n\nompl::base::Cost ompl::base::OptimizationObjective::identityCost() const\n{\n    return Cost(0.0);\n}\n\nompl::base::Cost ompl::base::OptimizationObjective::infiniteCost() const\n{\n    return Cost(std::numeric_limits<double>::infinity());\n}\n\nompl::base::Cost ompl::base::OptimizationObjective::initialCost(const State *) const\n{\n    return identityCost();\n}\n\nompl::base::Cost ompl::base::OptimizationObjective::terminalCost(const State *) const\n{\n    return identityCost();\n}\n\nbool ompl::base::OptimizationObjective::isSymmetric() const\n{\n    return si_->getStateSpace()->hasSymmetricInterpolate();\n}\n\nompl::base::Cost ompl::base::OptimizationObjective::averageStateCost(unsigned int numStates) const\n{\n    StateSamplerPtr ss = si_->allocStateSampler();\n    State *state = si_->allocState();\n    Cost totalCost(identityCost());\n\n    for (unsigned int i = 0; i < numStates; ++i)\n    {\n        ss->sampleUniform(state);\n        totalCost = combineCosts(totalCost, stateCost(state));\n    }\n\n    si_->freeState(state);\n\n    return Cost(totalCost.value() / (double)numStates);\n}\n\nvoid ompl::base::OptimizationObjective::setCostToGoHeuristic(const CostToGoHeuristic &costToGo)\n{\n    costToGoFn_ = costToGo;\n}\n\nbool ompl::base::OptimizationObjective::hasCostToGoHeuristic() const\n{\n    return static_cast<bool>(costToGoFn_);\n}\n\nompl::base::Cost ompl::base::OptimizationObjective::costToGo(const State *state, const Goal *goal) const\n{\n    if (hasCostToGoHeuristic())\n        return costToGoFn_(state, goal);\n\n    return identityCost();  // assumes that identity < all costs\n}\n\nompl::base::Cost ompl::base::OptimizationObjective::motionCostHeuristic(const State *, const State *) const\n{\n    return identityCost();  // assumes that identity < all costs\n}\n\nconst ompl::base::SpaceInformationPtr &ompl::base::OptimizationObjective::getSpaceInformation() const\n{\n    return si_;\n}\n\nompl::base::InformedSamplerPtr ompl::base::OptimizationObjective::allocInformedStateSampler(\n    const ProblemDefinitionPtr &probDefn, unsigned int maxNumberCalls) const\n{\n    // OMPL_INFORM(\"%s: No direct informed sampling scheme is defined, defaulting to rejection sampling.\",\n    //             description_.c_str());\n    // return std::make_shared<RejectionInfSampler>(probDefn, maxNumberCalls);\n    OMPL_INFORM(\"%s: Defaulting to path length direct inf sampling.\",\n                description_.c_str());\n    return std::make_shared<PathLengthDirectInfSampler>(probDefn, maxNumberCalls);\n}\n\nvoid ompl::base::OptimizationObjective::print(std::ostream &out) const\n{\n    out << \"Optimization Objective: \" << description_ << \" @\" << this << std::endl;\n    out << \"Optimization Threshold: \" << threshold_ << std::endl;\n}\n\nompl::base::Cost ompl::base::goalRegionCostToGo(const State *state, const Goal *goal)\n{\n    const auto *goalRegion = goal->as<GoalRegion>();\n\n    // Ensures that all states within the goal region's threshold to\n    // have a cost-to-go of exactly zero.\n    return Cost(std::max(goalRegion->distanceGoal(state) - goalRegion->getThreshold(), 0.0));\n}\n\nompl::base::MultiOptimizationObjective::MultiOptimizationObjective(const SpaceInformationPtr &si)\n  : OptimizationObjective(si), locked_(false)\n{\n}\n\nompl::base::MultiOptimizationObjective::Component::Component(OptimizationObjectivePtr obj, double weight)\n  : objective(std::move(obj)), weight(weight)\n{\n}\n\nvoid ompl::base::MultiOptimizationObjective::addObjective(const OptimizationObjectivePtr &objective, double weight)\n{\n    if (locked_)\n    {\n        throw Exception(\"This optimization objective is locked. No further objectives can be added.\");\n    }\n    else\n        components_.emplace_back(objective, weight);\n}\n\nstd::size_t ompl::base::MultiOptimizationObjective::getObjectiveCount() const\n{\n    return components_.size();\n}\n\nconst ompl::base::OptimizationObjectivePtr &ompl::base::MultiOptimizationObjective::getObjective(unsigned int idx) const\n{\n    if (components_.size() > idx)\n        return components_[idx].objective;\n    throw Exception(\"Objective index does not exist.\");\n}\n\ndouble ompl::base::MultiOptimizationObjective::getObjectiveWeight(unsigned int idx) const\n{\n    if (components_.size() > idx)\n        return components_[idx].weight;\n    throw Exception(\"Objective index does not exist.\");\n}\n\nvoid ompl::base::MultiOptimizationObjective::setObjectiveWeight(unsigned int idx, double weight)\n{\n    if (components_.size() > idx)\n        components_[idx].weight = weight;\n    else\n        throw Exception(\"Objecitve index does not exist.\");\n}\n\nvoid ompl::base::MultiOptimizationObjective::lock()\n{\n    locked_ = true;\n}\n\nbool ompl::base::MultiOptimizationObjective::isLocked() const\n{\n    return locked_;\n}\n\nompl::base::Cost ompl::base::MultiOptimizationObjective::stateCost(const State *s) const\n{\n    Cost c = identityCost();\n    for (const auto &component : components_)\n    {\n        c = Cost(c.value() + component.weight * (component.objective->stateCost(s).value()));\n    }\n\n    return c;\n}\n\nompl::base::Cost ompl::base::MultiOptimizationObjective::motionCost(const State *s1, const State *s2) const\n{\n    Cost c = identityCost();\n    for (const auto &component : components_)\n    {\n        c = Cost(c.value() + component.weight * (component.objective->motionCost(s1, s2).value()));\n    }\n\n    return c;\n}\n\nompl::base::OptimizationObjectivePtr ompl::base::operator+(const OptimizationObjectivePtr &a,\n                                                           const OptimizationObjectivePtr &b)\n{\n    std::vector<MultiOptimizationObjective::Component> components;\n\n    if (a)\n    {\n        if (auto *mult = dynamic_cast<MultiOptimizationObjective *>(a.get()))\n        {\n            for (std::size_t i = 0; i < mult->getObjectiveCount(); ++i)\n            {\n                components.emplace_back(mult->getObjective(i), mult->getObjectiveWeight(i));\n            }\n        }\n        else\n            components.emplace_back(a, 1.0);\n    }\n\n    if (b)\n    {\n        if (auto *mult = dynamic_cast<MultiOptimizationObjective *>(b.get()))\n        {\n            for (std::size_t i = 0; i < mult->getObjectiveCount(); ++i)\n            {\n                components.emplace_back(mult->getObjective(i), mult->getObjectiveWeight(i));\n            }\n        }\n        else\n            components.emplace_back(b, 1.0);\n    }\n\n    auto multObj(std::make_shared<MultiOptimizationObjective>(a->getSpaceInformation()));\n    for (const auto &comp : components)\n        multObj->addObjective(comp.objective, comp.weight);\n\n    return multObj;\n}\n\nompl::base::OptimizationObjectivePtr ompl::base::operator*(double weight, const OptimizationObjectivePtr &a)\n{\n    std::vector<MultiOptimizationObjective::Component> components;\n\n    if (a)\n    {\n        if (auto *mult = dynamic_cast<MultiOptimizationObjective *>(a.get()))\n        {\n            for (std::size_t i = 0; i < mult->getObjectiveCount(); ++i)\n            {\n                components.emplace_back(mult->getObjective(i), weight * mult->getObjectiveWeight(i));\n            }\n        }\n        else\n            components.emplace_back(a, weight);\n    }\n\n    auto multObj(std::make_shared<MultiOptimizationObjective>(a->getSpaceInformation()));\n    for (auto const &comp : components)\n        multObj->addObjective(comp.objective, comp.weight);\n\n    return multObj;\n}\n\nompl::base::OptimizationObjectivePtr ompl::base::operator*(const OptimizationObjectivePtr &a, double weight)\n{\n    return weight * a;\n}\n"
        }
    ]
}