{
    "sourceFile": "src/ompl/base/Path.h",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1684419529326,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1684419536850,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,9 +109,9 @@\n             virtual double length() const = 0;\n \n             /** \\brief Return the cost of the path with respect to a\n                 specified optimization objective. */\n-            virtual Cost cost(const OptimizationObjectivePtr &obj, const bool use_) const = 0;\n+            virtual Cost cost(const OptimizationObjectivePtr &obj, const bool use_use_worst_motion_cost = false) const = 0;\n \n             /** \\brief Check if the path is valid */\n             virtual bool check() const = 0;\n \n"
                }
            ],
            "date": 1684419529326,
            "name": "Commit-0",
            "content": "/*********************************************************************\n* Software License Agreement (BSD License)\n*\n*  Copyright (c) 2008, Willow Garage, Inc.\n*  All rights reserved.\n*\n*  Redistribution and use in source and binary forms, with or without\n*  modification, are permitted provided that the following conditions\n*  are met:\n*\n*   * Redistributions of source code must retain the above copyright\n*     notice, this list of conditions and the following disclaimer.\n*   * Redistributions in binary form must reproduce the above\n*     copyright notice, this list of conditions and the following\n*     disclaimer in the documentation and/or other materials provided\n*     with the distribution.\n*   * Neither the name of the Willow Garage nor the names of its\n*     contributors may be used to endorse or promote products derived\n*     from this software without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*********************************************************************/\n\n/* Author: Ioan Sucan */\n\n#ifndef OMPL_BASE_PATH_\n#define OMPL_BASE_PATH_\n\n#include \"ompl/util/ClassForward.h\"\n#include \"ompl/base/Cost.h\"\n#include <iostream>\n#include <boost/concept_check.hpp>\n#include <utility>\n\nnamespace ompl\n{\n    namespace base\n    {\n        /// @cond IGNORE\n        OMPL_CLASS_FORWARD(SpaceInformation);\n        /// @endcond\n\n        /// @cond IGNORE\n        OMPL_CLASS_FORWARD(OptimizationObjective);\n        /// @endcond\n\n        /// @cond IGNORE\n        /** \\brief Forward declaration of ompl::base::Path */\n        OMPL_CLASS_FORWARD(Path);\n        /// @endcond\n\n        /** \\class ompl::base::PathPtr\n            \\brief A shared pointer wrapper for ompl::base::Path */\n\n        /** \\brief Abstract definition of a path */\n        class Path\n        {\n        public:\n            // non-copyable\n            Path(const Path &) = delete;\n            Path &operator=(const Path &) = delete;\n\n            /** \\brief Constructor. A path must always know the space information it is part of */\n            Path(SpaceInformationPtr si) : si_(std::move(si))\n            {\n            }\n\n            /** \\brief Destructor */\n            virtual ~Path() = default;\n\n            /** \\brief Get the space information associated to this class */\n            const SpaceInformationPtr &getSpaceInformation() const\n            {\n                return si_;\n            }\n\n            /** \\brief Cast this instance to a desired type. */\n            template <class T>\n            const T *as() const\n            {\n                /** \\brief Make sure the type we are allocating is indeed a Path */\n                BOOST_CONCEPT_ASSERT((boost::Convertible<T *, Path *>));\n\n                return static_cast<const T *>(this);\n            }\n\n            /** \\brief Cast this instance to a desired type. */\n            template <class T>\n            T *as()\n            {\n                /** \\brief Make sure the type we are allocating is indeed a Path */\n                BOOST_CONCEPT_ASSERT((boost::Convertible<T *, Path *>));\n\n                return static_cast<T *>(this);\n            }\n\n            /** \\brief Return the length of a path */\n            virtual double length() const = 0;\n\n            /** \\brief Return the cost of the path with respect to a\n                specified optimization objective. */\n            virtual Cost cost(const OptimizationObjectivePtr &obj, const bool use_) const = 0;\n\n            /** \\brief Check if the path is valid */\n            virtual bool check() const = 0;\n\n            /** \\brief Print the path to a stream */\n            virtual void print(std::ostream &out) const = 0;\n\n        protected:\n            /** \\brief The space information this path is part of */\n            SpaceInformationPtr si_;\n        };\n    }\n}\n\n#endif\n"
        }
    ]
}