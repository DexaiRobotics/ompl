{
    "sourceFile": "src/ompl/tools/thunder/src/SPARSdb.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 13,
            "patches": [
                {
                    "date": 1685471751251,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1685471757735,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1810,9 +1810,9 @@\n \n     data.properties[\"iterations INTEGER\"] = std::to_string(iterations_);\n }\n \n-void ompl::geometric::SPARSdb::setPlannerData(const base::PlannerData &data, const bool validate)\n+void ompl::geometric::SPARSdb::setPlannerData(const base::PlannerData &data, const bool validate_data)\n {\n     // Check that the query vertex is initialized (used for internal nearest neighbor searches)\n     checkQueryStateInitialization();\n \n"
                },
                {
                    "date": 1685471813478,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1810,9 +1810,9 @@\n \n     data.properties[\"iterations INTEGER\"] = std::to_string(iterations_);\n }\n \n-void ompl::geometric::SPARSdb::setPlannerData(const base::PlannerData &data, const bool validate_data)\n+void ompl::geometric::SPARSdb::setPlannerData(const base::PlannerData &data, const bool &validate_data)\n {\n     // Check that the query vertex is initialized (used for internal nearest neighbor searches)\n     checkQueryStateInitialization();\n \n"
                },
                {
                    "date": 1685471912641,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1830,8 +1830,9 @@\n     verbose_ = false;\n \n     OMPL_INFORM(\"Loading vertices:\");\n     // Add the nodes to the graph\n+    \n     for (std::size_t vertexID = 0; vertexID < data.numVertices(); ++vertexID)\n     {\n         // Get the state from loaded planner data\n         const base::State *oldState = data.getVertex(vertexID).getState();\n"
                },
                {
                    "date": 1685471923122,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1830,9 +1830,9 @@\n     verbose_ = false;\n \n     OMPL_INFORM(\"Loading vertices:\");\n     // Add the nodes to the graph\n-    \n+    std::vector<std::size\n     for (std::size_t vertexID = 0; vertexID < data.numVertices(); ++vertexID)\n     {\n         // Get the state from loaded planner data\n         const base::State *oldState = data.getVertex(vertexID).getState();\n"
                },
                {
                    "date": 1685471936118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1830,9 +1830,9 @@\n     verbose_ = false;\n \n     OMPL_INFORM(\"Loading vertices:\");\n     // Add the nodes to the graph\n-    std::vector<std::size\n+    std::vector<std::size_t> skipped_vertices {};\n     for (std::size_t vertexID = 0; vertexID < data.numVertices(); ++vertexID)\n     {\n         // Get the state from loaded planner data\n         const base::State *oldState = data.getVertex(vertexID).getState();\n"
                },
                {
                    "date": 1685472097087,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1868,8 +1868,9 @@\n             {\n                 OMPL_INFORM(\"    Adding edge from vertex id %d to id %d into edgeList\", fromVertex, toVertex);\n                 OMPL_INFORM(\"      Vertex %d to %d\", m, n);\n             }\n+            // check if fromVert\n             connectGuards(m, n);\n         }\n     }  // for\n \n"
                },
                {
                    "date": 1685472113995,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1868,9 +1868,9 @@\n             {\n                 OMPL_INFORM(\"    Adding edge from vertex id %d to id %d into edgeList\", fromVertex, toVertex);\n                 OMPL_INFORM(\"      Vertex %d to %d\", m, n);\n             }\n-            // check if fromVert\n+            // check if fromVertex or toVertex is one of the skipp_vertices. If it is, do not add the edge.\n             connectGuards(m, n);\n         }\n     }  // for\n \n"
                },
                {
                    "date": 1685472127477,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1869,8 +1869,10 @@\n                 OMPL_INFORM(\"    Adding edge from vertex id %d to id %d into edgeList\", fromVertex, toVertex);\n                 OMPL_INFORM(\"      Vertex %d to %d\", m, n);\n             }\n             // check if fromVertex or toVertex is one of the skipp_vertices. If it is, do not add the edge.\n+            // else, check the edge for collision, if not collision-free, do not add it.\n+            \n             connectGuards(m, n);\n         }\n     }  // for\n \n"
                },
                {
                    "date": 1685472134114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1870,9 +1870,9 @@\n                 OMPL_INFORM(\"      Vertex %d to %d\", m, n);\n             }\n             // check if fromVertex or toVertex is one of the skipp_vertices. If it is, do not add the edge.\n             // else, check the edge for collision, if not collision-free, do not add it.\n-            \n+            // else, add it.\n             connectGuards(m, n);\n         }\n     }  // for\n \n"
                },
                {
                    "date": 1685472141400,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1840,8 +1840,10 @@\n \n         // Get the tag, which in this application represents the vertex type\n         auto type = static_cast<GuardType>(data.getVertex(vertexID).getTag());\n \n+\n+        \n         // ADD GUARD\n         idToVertex.push_back(addGuard(state, type));\n     }\n \n"
                },
                {
                    "date": 1685472177561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1841,9 +1841,9 @@\n         // Get the tag, which in this application represents the vertex type\n         auto type = static_cast<GuardType>(data.getVertex(vertexID).getTag());\n \n \n-        \n+        // check the node for collision. If not collision-free, do not add it to roadmap, and remember the vertexID so that we skip connecting edges to it.\n         // ADD GUARD\n         idToVertex.push_back(addGuard(state, type));\n     }\n \n"
                },
                {
                    "date": 1685472184051,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1841,9 +1841,9 @@\n         // Get the tag, which in this application represents the vertex type\n         auto type = static_cast<GuardType>(data.getVertex(vertexID).getTag());\n \n \n-        // check the node for collision. If not collision-free, do not add it to roadmap, and remember the vertexID () so that we skip connecting edges to it later.\n+        // check the node for collision. If not collision-free, do not add it to roadmap, and remember the vertexID (in) so that we skip connecting edges to it later.\n         // ADD GUARD\n         idToVertex.push_back(addGuard(state, type));\n     }\n \n"
                },
                {
                    "date": 1685716433047,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1891,9 +1891,9 @@\n                 if (!si_->checkMotion(fromState, toState))\n                     // edge invalid, skip.\n                     continue;\n                 // need to recalculate edge weight\n-                \n+                P<\n                 edge_weight = std::nullopt;\n             }\n             if (edge_weight.has_value())\n             {\n"
                }
            ],
            "date": 1685471751251,
            "name": "Commit-0",
            "content": "/*********************************************************************\n * Software License Agreement (BSD License)\n *\n *  Copyright (c) 2013, Rutgers the State University of New Jersey, New Brunswick\n *  Copyright (c) 2014, University of Colorado, Boulder\n *  All Rights Reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.\n *   * Neither the name of Rutgers University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n *********************************************************************/\n\n/* Author: Andrew Dobson, Dave Coleman */\n\n#include <ompl/base/goals/GoalSampleableRegion.h>\n#include <ompl/geometric/planners/prm/ConnectionStrategy.h>\n#include <ompl/tools/config/SelfConfig.h>\n#include <ompl/tools/thunder/SPARSdb.h>\n#include <ompl/util/Console.h>\n#include <boost/foreach.hpp>\n#include <boost/graph/astar_search.hpp>\n#include <boost/graph/incremental_components.hpp>\n#include <boost/property_map/vector_property_map.hpp>\n#include <random>\n\n// Allow hooks for visualizing planner\n//#define OMPL_THUNDER_DEBUG\n\n#define foreach BOOST_FOREACH\n#define foreach_reverse BOOST_REVERSE_FOREACH\n\n// edgeWeightMap methods ////////////////////////////////////////////////////////////////////////////\n\nBOOST_CONCEPT_ASSERT(\n    (boost::ReadablePropertyMapConcept<ompl::geometric::SPARSdb::edgeWeightMap, ompl::geometric::SPARSdb::Edge>));\n\nompl::geometric::SPARSdb::edgeWeightMap::edgeWeightMap(const Graph &graph, const EdgeCollisionStateMap &collisionStates)\n  : g_(graph), collisionStates_(collisionStates)\n{\n}\n\ndouble ompl::geometric::SPARSdb::edgeWeightMap::get(Edge e) const\n{\n    // Get the status of collision checking for this edge\n    if (collisionStates_[e] == IN_COLLISION)\n        return std::numeric_limits<double>::infinity();\n\n    return boost::get(boost::edge_weight, g_, e);\n}\n\nnamespace boost\n{\n    double get(const ompl::geometric::SPARSdb::edgeWeightMap &m, const ompl::geometric::SPARSdb::Edge &e)\n    {\n        return m.get(e);\n    }\n}\n\n// CustomVisitor methods ////////////////////////////////////////////////////////////////////////////\n\nBOOST_CONCEPT_ASSERT(\n    (boost::AStarVisitorConcept<ompl::geometric::SPARSdb::CustomVisitor, ompl::geometric::SPARSdb::Graph>));\n\nompl::geometric::SPARSdb::CustomVisitor::CustomVisitor(Vertex goal) : goal(goal)\n{\n}\n\nvoid ompl::geometric::SPARSdb::CustomVisitor::examine_vertex(Vertex u, const Graph &) const\n{\n    if (u == goal)\n        throw foundGoalException();\n}\n\n// SPARSdb methods ////////////////////////////////////////////////////////////////////////////////////////\n\nompl::geometric::SPARSdb::SPARSdb(const base::SpaceInformationPtr &si)\n  : base::Planner(si, \"SPARSdb\")\n  // Numeric variables\n  , nearSamplePoints_((2 * si_->getStateDimension()))\n  // Property accessors of edges\n  , edgeWeightProperty_(boost::get(boost::edge_weight, g_))\n  , edgeCollisionStateProperty_(boost::get(edge_collision_state_t(), g_))\n  // Property accessors of vertices\n  , stateProperty_(boost::get(vertex_state_t(), g_))\n  , colorProperty_(boost::get(vertex_color_t(), g_))\n  , interfaceDataProperty_(boost::get(vertex_interface_data_t(), g_))\n  // Disjoint set accessors\n  , disjointSets_(boost::get(boost::vertex_rank, g_), boost::get(boost::vertex_predecessor, g_))\n{\n    specs_.recognizedGoal = base::GOAL_SAMPLEABLE_REGION;\n    specs_.approximateSolutions = false;\n    specs_.optimizingPaths = true;\n\n    psimp_ = std::make_shared<PathSimplifier>(si_);\n\n    Planner::declareParam<double>(\"stretch_factor\", this, &SPARSdb::setStretchFactor, &SPARSdb::getStretchFactor,\n                                  \"1.1:0.1:3.0\");\n    Planner::declareParam<double>(\"sparse_delta_fraction\", this, &SPARSdb::setSparseDeltaFraction,\n                                  &SPARSdb::getSparseDeltaFraction, \"0.0:0.01:1.0\");\n    Planner::declareParam<double>(\"dense_delta_fraction\", this, &SPARSdb::setDenseDeltaFraction,\n                                  &SPARSdb::getDenseDeltaFraction, \"0.0:0.0001:0.1\");\n    Planner::declareParam<unsigned int>(\"max_failures\", this, &SPARSdb::setMaxFailures, &SPARSdb::getMaxFailures,\n                                        \"100:10:3000\");\n}\n\nompl::geometric::SPARSdb::~SPARSdb()\n{\n    freeMemory();\n}\n\nvoid ompl::geometric::SPARSdb::setup()\n{\n    Planner::setup();\n    if (!nn_)\n        nn_.reset(tools::SelfConfig::getDefaultNearestNeighbors<Vertex>(this));\n    nn_->setDistanceFunction([this](const Vertex a, const Vertex b)\n                             {\n                                 return distanceFunction(a, b);\n                             });\n    double maxExt = si_->getMaximumExtent();\n    sparseDelta_ = sparseDeltaFraction_ * maxExt;\n    denseDelta_ = denseDeltaFraction_ * maxExt;\n\n    if (!sampler_)\n        sampler_ = si_->allocValidStateSampler();\n}\n\nvoid ompl::geometric::SPARSdb::setProblemDefinition(const base::ProblemDefinitionPtr &pdef)\n{\n    Planner::setProblemDefinition(pdef);\n    clearQuery();\n}\n\nvoid ompl::geometric::SPARSdb::clearQuery()\n{\n    startM_.clear();\n    goalM_.clear();\n    pis_.restart();\n}\n\nvoid ompl::geometric::SPARSdb::clear()\n{\n    Planner::clear();\n    clearQuery();\n    resetFailures();\n    iterations_ = 0;\n    freeMemory();\n    if (nn_)\n        nn_->clear();\n}\n\nvoid ompl::geometric::SPARSdb::freeMemory()\n{\n    Planner::clear();\n    sampler_.reset();\n\n    foreach (Vertex v, boost::vertices(g_))\n    {\n        foreach (InterfaceData &d, interfaceDataProperty_[v].interfaceHash | boost::adaptors::map_values)\n            d.clear(si_);\n        if (stateProperty_[v] != nullptr)\n            si_->freeState(stateProperty_[v]);\n        stateProperty_[v] = nullptr;\n    }\n    g_.clear();\n\n    if (nn_)\n        nn_->clear();\n}\n\nbool ompl::geometric::SPARSdb::getSimilarPaths(int /*nearestK*/, const base::State *start, const base::State *goal,\n                                               CandidateSolution &candidateSolution,\n                                               const base::PlannerTerminationCondition &ptc)\n{\n    // TODO: nearestK unused\n\n    // Get neighbors near start and goal. Note: potentially they are not *visible* - will test for this later\n\n    // Start\n    OMPL_INFORM(\"Looking for a node near the problem start\");\n    if (!findGraphNeighbors(start, startVertexCandidateNeighbors_))\n    {\n        OMPL_INFORM(\"No graph neighbors found for start within radius %f\", sparseDelta_);\n        return false;\n    }\n    if (verbose_)\n        OMPL_INFORM(\"Found %d nodes near start\", startVertexCandidateNeighbors_.size());\n\n    // Goal\n    OMPL_INFORM(\"Looking for a node near the problem goal\");\n    if (!findGraphNeighbors(goal, goalVertexCandidateNeighbors_))\n    {\n        OMPL_INFORM(\"No graph neighbors found for goal within radius %f\", sparseDelta_);\n        return false;\n    }\n    if (verbose_)\n        OMPL_INFORM(\"Found %d nodes near goal\", goalVertexCandidateNeighbors_.size());\n\n    // Get paths between start and goal\n    bool result =\n        getPaths(startVertexCandidateNeighbors_, goalVertexCandidateNeighbors_, start, goal, candidateSolution, ptc);\n    \n    // Error check\n    if (!result)\n    {\n        OMPL_INFORM(\"getSimilarPaths(): SPARSdb returned FALSE for getPaths\");\n        return false;\n    }\n    if (!candidateSolution.path_)\n    {\n        OMPL_ERROR(\"getSimilarPaths(): SPARSdb returned solution is nullptr\");\n        return false;\n    }\n\n    // Debug output\n    if (false)\n    {\n        ompl::geometric::PathGeometric geometricSolution =\n            static_cast<ompl::geometric::PathGeometric &>(*candidateSolution.path_);\n\n        for (std::size_t i = 0; i < geometricSolution.getStateCount(); ++i)\n        {\n            OMPL_INFORM(\"  getSimilarPaths(): Adding state %f to plannerData\", i);\n            si_->printState(geometricSolution.getState(i), std::cout);\n        }\n    }\n\n    return result;\n}\n\nbool ompl::geometric::SPARSdb::getPaths(const std::vector<Vertex> &candidateStarts,\n                                        const std::vector<Vertex> &candidateGoals, const base::State *actualStart,\n                                        const base::State *actualGoal, CandidateSolution &candidateSolution,\n                                        const base::PlannerTerminationCondition &ptc)\n{\n    // Try every combination of nearby start and goal pairs\n    foreach (Vertex start, candidateStarts)\n    {\n        // Check if this start is visible from the actual start\n        if (!si_->checkMotion(actualStart, stateProperty_[start]))\n        {\n            if (verbose_)\n                OMPL_WARN(\"FOUND CANDIDATE START THAT IS NOT VISIBLE \");\n            continue;  // this is actually not visible\n        }\n\n        foreach (Vertex goal, candidateGoals)\n        {\n            if (verbose_)\n                OMPL_INFORM(\"  foreach_goal: Checking motion from  %d to %d\", actualGoal, stateProperty_[goal]);\n\n            // Check if our planner is out of time\n            if (ptc == true)\n            {\n                OMPL_DEBUG(\"getPaths function interrupted because termination condition is true.\");\n                return false;\n            }\n\n            // Check if this goal is visible from the actual goal\n            if (!si_->checkMotion(actualGoal, stateProperty_[goal]))\n            {\n                if (verbose_)\n                    OMPL_INFORM(\"FOUND CANDIDATE GOAL THAT IS NOT VISIBLE! \");\n                continue;  // this is actually not visible\n            }\n\n            // Repeatidly search through graph for connection then check for collisions then repeat\n            if (lazyCollisionSearch(start, goal, actualStart, actualGoal, candidateSolution, ptc))\n            {\n                // Found a path\n                return true;\n            }\n            else\n            {\n                // Did not find a path\n                OMPL_INFORM(\"Did not find a path, looking for other start/goal combinations \");\n            }\n\n        }  // foreach\n    }      // foreach\n\n    return false;\n}\n\nbool ompl::geometric::SPARSdb::lazyCollisionSearch(const Vertex &start, const Vertex &goal,\n                                                   const base::State *actualStart, const base::State *actualGoal,\n                                                   CandidateSolution &candidateSolution,\n                                                   const base::PlannerTerminationCondition &ptc)\n{\n    base::Goal *g = pdef_->getGoal().get();  // for checking isStartGoalPairValid\n\n    // Vector to store candidate paths in before they are converted to PathPtrs\n    std::vector<Vertex> vertexPath;\n\n    // decide if start and goal are connected\n    // TODO this does not compute dynamic graphcs\n    // i.e. it will say its the same components even when an edge has been disabled\n    bool same_component =\n        true;  // sameComponent(start, goal); // TODO is this important? I disabled it during dev and never used it\n\n    // Check if the chosen start and goal can be used together to satisfy problem\n    if (!same_component)\n    {\n        if (verbose_)\n            OMPL_INFORM(\"    Goal and start are not part of same component, skipping \");\n        return false;\n    }\n\n    // TODO: remove this because start and goal are not either start nor goals\n    if (!g->isStartGoalPairValid(stateProperty_[goal], stateProperty_[start]))\n    {\n        if (verbose_)\n            OMPL_INFORM(\"    Start and goal pair are not valid combinations, skipping \");\n        return false;\n    }\n\n    // Make sure that the start and goal aren't so close together that they find the same vertex\n    if (start == goal)\n    {\n        if (verbose_)\n            OMPL_INFORM(\"    Start equals goal, skipping \");\n        return false;\n    }\n\n    // Keep looking for paths between chosen start and goal until one is found that is valid,\n    // or no further paths can be found between them because of disabled edges\n    // this is necessary for lazy collision checking i.e. rerun after marking invalid edges we found\n    bool havePartialSolution = false;\n    while (true)\n    {\n        if (verbose_)\n            OMPL_INFORM(\"      while true: look for valid paths between start and goal\");\n\n        // Check if our planner is out of time\n        if (ptc == true)\n        {\n            OMPL_DEBUG(\"lazyCollisionSearch: function interrupted because termination condition is true.\");\n            return false;\n        }\n\n        // Attempt to find a solution from start to goal\n        if (!constructSolution(start, goal, vertexPath))\n        {\n            // We will stop looking through this start-goal combination, but perhaps this partial solution is good\n            if (verbose_)\n                OMPL_INFORM(\"        unable to construct solution between start and goal using astar\");\n\n            // no solution path found. check if a previous partially correct solution was found\n            if (havePartialSolution && false)  // TODO: re-implement partial solution logic\n            {\n                if (verbose_)\n                    OMPL_INFORM(\"has partial solution \");\n                // Save this candidateSolution for later\n                convertVertexPathToStatePath(vertexPath, actualStart, actualGoal, candidateSolution, true);\n                return false;\n            }\n\n            if (verbose_)\n                OMPL_INFORM(\"        no partial solution found on this astar search, keep looking through start-goal \"\n                            \"combos\");\n\n            // no path found what so ever\n            // return false;\n            return false;\n        }\n        havePartialSolution = true;  // we have found at least one path at this point. may be invalid\n\n        if (verbose_)\n        {\n            OMPL_INFORM(\"        has at least a partial solution, maybe exact solution\");\n            OMPL_INFORM(\"        Solution has %d vertices\", vertexPath.size());\n        }\n\n        // Check if all the points in the potential solution are valid\n        if (!collisionCheckOnRecall_ || lazyCollisionCheck(vertexPath, ptc))\n        {\n            if (verbose_)\n            {\n                OMPL_INFORM(\"---------- lazy collision check returned valid \");\n            }\n\n            // the path is valid, we are done!\n            convertVertexPathToStatePath(vertexPath, actualStart, actualGoal, candidateSolution, true);\n            return true;\n        }\n        // else, loop with updated graph that has the invalid edges/states disabled\n    }  // while\n\n    // we never found a valid path\n    return false;\n}\n\nbool ompl::geometric::SPARSdb::constructSolution(const Vertex start, const Vertex goal,\n                                                 std::vector<Vertex> &vertexPath) const\n{\n    auto *vertexPredecessors = new Vertex[boost::num_vertices(g_)];\n    bool foundGoal = false;\n\n    auto *vertexDistances = new double[boost::num_vertices(g_)];\n\n    try\n    {\n        boost::astar_search(g_,     // graph\n                            start,  // start state\n                            [this, goal](const Vertex v)\n                            {\n                                return heuristicScaling_ * distanceFunction(v, goal);\n                            },  // the heuristic\n                            // ability to disable edges (set cost to inifinity):\n                            boost::weight_map(edgeWeightMap(g_, edgeCollisionStateProperty_))\n                                .predecessor_map(vertexPredecessors)\n                                .distance_map(&vertexDistances[0])\n                                .visitor(CustomVisitor(goal)));\n    }\n    catch (ompl::geometric::SPARSdb::foundGoalException &)\n    {\n        // the custom exception from CustomVisitor\n        if (verbose_ && false)\n        {\n            OMPL_INFORM(\"constructSolution: Astar found goal vertex ------------------------\");\n            OMPL_INFORM(\"distance to goal: %f\", vertexDistances[goal]);\n        }\n\n        if (vertexDistances[goal] > 1.7e+308)  // terrible hack for detecting infinity\n        // double diff = d[goal] - std::numeric_limits<double>::infinity();\n        // if ((diff < std::numeric_limits<double>::epsilon()) && (-diff < std::numeric_limits<double>::epsilon()))\n        // check if the distance to goal is inifinity. if so, it is unreachable\n        // if (d[goal] >= std::numeric_limits<double>::infinity())\n        {\n            if (verbose_)\n                OMPL_INFORM(\"Distance to goal is infinity\");\n            foundGoal = false;\n        }\n        else\n        {\n            // Only clear the vertexPath after we know we have a new solution, otherwise it might have a good\n            // previous one\n            vertexPath.clear();  // remove any old solutions\n\n            // Trace back a shortest path in reverse and only save the states\n            Vertex v;\n            for (v = goal; v != vertexPredecessors[v]; v = vertexPredecessors[v])\n            {\n                vertexPath.push_back(v);\n            }\n            if (v != goal)  // TODO explain this because i don't understand\n            {\n                vertexPath.push_back(v);\n            }\n\n            foundGoal = true;\n        }\n    }\n\n    delete[] vertexPredecessors;\n    delete[] vertexDistances;\n\n    // No solution found from start to goal\n    return foundGoal;\n}\n\nbool ompl::geometric::SPARSdb::lazyCollisionCheck(std::vector<Vertex> &vertexPath,\n                                                  const base::PlannerTerminationCondition &ptc)\n{\n    OMPL_DEBUG(\"Starting lazy collision checking\");\n\n    bool hasInvalidEdges = false;\n\n    // Initialize\n    Vertex fromVertex = vertexPath[0];\n    Vertex toVertex;\n\n    // Loop through every pair of states and make sure path is valid.\n    for (std::size_t toID = 1; toID < vertexPath.size(); ++toID)\n    {\n        // Increment location on path\n        toVertex = vertexPath[toID];\n\n        // Check if our planner is out of time\n        if (ptc == true)\n        {\n            OMPL_DEBUG(\"Lazy collision check function interrupted because termination condition is true.\");\n            return false;\n        }\n\n        Edge thisEdge = boost::edge(fromVertex, toVertex, g_).first;\n\n        // Has this edge already been checked before?\n        if (edgeCollisionStateProperty_[thisEdge] == NOT_CHECKED)\n        {\n            // Check path between states\n            if (!si_->checkMotion(stateProperty_[fromVertex], stateProperty_[toVertex]))\n            {\n                // Path between (from, to) states not valid, disable the edge\n                OMPL_INFORM(\"  DISABLING EDGE from vertex %f to vertex %f\", fromVertex, toVertex);\n\n                // Disable edge\n                edgeCollisionStateProperty_[thisEdge] = IN_COLLISION;\n            }\n            else\n            {\n                // Mark edge as free so we no longer need to check for collision\n                edgeCollisionStateProperty_[thisEdge] = FREE;\n            }\n        }\n\n        // Check final result\n        if (edgeCollisionStateProperty_[thisEdge] == IN_COLLISION)\n        {\n            // Remember that this path is no longer valid, but keep checking remainder of path edges\n            hasInvalidEdges = true;\n        }\n\n        // switch vertex focus\n        fromVertex = toVertex;\n    }\n\n    OMPL_INFORM(\"Done lazy collision checking\");\n\n    // TODO: somewhere in the code we need to reset all edges collision status back to NOT_CHECKED for future queries\n\n    // Only return true if nothing was found invalid\n    return !hasInvalidEdges;\n}\n\nbool ompl::geometric::SPARSdb::sameComponent(Vertex m1, Vertex m2)\n{\n    return boost::same_component(m1, m2, disjointSets_);\n}\n\nbool ompl::geometric::SPARSdb::reachedFailureLimit() const\n{\n    return consecutiveFailures_ >= maxFailures_;\n}\n\nvoid ompl::geometric::SPARSdb::printDebug(std::ostream &out) const\n{\n    out << \"SPARSdb Debug Output: \" << std::endl;\n    out << \"  Settings: \" << std::endl;\n    out << \"    Max Failures: \" << getMaxFailures() << std::endl;\n    out << \"    Dense Delta Fraction: \" << getDenseDeltaFraction() << std::endl;\n    out << \"    Sparse Delta Fraction: \" << getSparseDeltaFraction() << std::endl;\n    out << \"    Sparse Delta: \" << sparseDelta_ << std::endl;\n    out << \"    Stretch Factor: \" << getStretchFactor() << std::endl;\n    out << \"    Maximum Extent: \" << si_->getMaximumExtent() << std::endl;\n    out << \"  Status: \" << std::endl;\n    out << \"    Vertices Count: \" << getNumVertices() << std::endl;\n    out << \"    Edges Count:    \" << getNumEdges() << std::endl;\n    out << \"    Iterations: \" << getIterations() << std::endl;\n    out << \"    Consecutive Failures: \" << consecutiveFailures_ << std::endl;\n    out << \"    Number of guards: \" << nn_->size() << std::endl << std::endl;\n}\n\nbool ompl::geometric::SPARSdb::getGuardSpacingFactor(const double pathLength, int &numGuards, double &spacingFactor)\n{\n    static const double factorHigh = 1.9;\n    static const double factorLow = 1.3;\n    double minPathLength = sparseDelta_ * factorLow;\n\n    // Check if the path length is too short\n    if (pathLength < minPathLength)\n    {\n        OMPL_INFORM(\"Path length is too short to get a correct sparcing factor: length: %f, min: %f \", pathLength,\n                    minPathLength);\n        spacingFactor = factorLow;\n        return true;  // still attempt\n    }\n\n    // Get initial guess using med value\n    double numGuardsFraction = pathLength / (sparseDelta_ * factorLow);\n    if (verbose_)\n    {\n        OMPL_INFORM(\"getGuardSpacingFactor: \");\n        OMPL_INFORM(\"  pathLength: %f\", pathLength);\n        OMPL_INFORM(\"  sparseDelta: %f\", sparseDelta_);\n        OMPL_INFORM(\"  min pathLength: %f\", minPathLength);\n        OMPL_INFORM(\"  numGuardsFraction: %f\", numGuardsFraction);\n    }\n\n    // Round down to nearest integer\n    numGuards = numGuardsFraction;\n\n    static std::size_t MAX_ATTEMPTS = 4;\n    for (std::size_t i = 0; i < MAX_ATTEMPTS; ++i)\n    {\n        if (verbose_)\n            OMPL_INFORM(\"  numGuards: %d\", numGuards);\n\n        // Find the factor to achieve this number of guards\n        spacingFactor = pathLength / (sparseDelta_ * numGuards);\n        if (verbose_)\n            OMPL_INFORM(\"  new spacingFactor: %f\", spacingFactor);\n\n        // Check if this factor is too low\n        if (spacingFactor < factorLow)\n        {\n            if (verbose_)\n                OMPL_INFORM(\"  spacing factor is too low \");\n            numGuards++;\n            continue;\n        }\n        else if (spacingFactor > factorHigh)\n        {\n            if (verbose_)\n                OMPL_INFORM(\"  spacing factor is too high \");\n            numGuards--;\n            continue;\n        }\n        else\n            return true;  // a good value\n    }\n\n    OMPL_ERROR(\"Unable to find correct spacing factor - perhaps this is a bug\");\n    spacingFactor = factorLow;\n    return true;  // still attempt\n}\n\nbool ompl::geometric::SPARSdb::addPathToRoadmap(const base::PlannerTerminationCondition &ptc,\n                                                ompl::geometric::PathGeometric &solutionPath)\n{\n    // Check that the query vertex is initialized (used for internal nearest neighbor searches)\n    checkQueryStateInitialization();\n\n    // Error check\n    if (solutionPath.getStateCount() < 2)\n    {\n        OMPL_ERROR(\"Less than 2 states were passed to addPathToRoadmap in the solution path\");\n        return false;\n    }\n\n    // Find spacing factor - 2.0 would be a perfect amount, but we leave room for rounding/interpolation errors and\n    // curves in path\n    int numGuards;  // unused variable that indicates how many guards we will add\n    double spacingFactor;\n    if (!getGuardSpacingFactor(solutionPath.length(), numGuards, spacingFactor))\n        return false;\n\n    OMPL_DEBUG(\"The expected number of necessary coverage guards is calculated to be %i from the original path state count \"\n               \"%i\",\n               numGuards, solutionPath.getStateCount());\n\n    if (pathSamplingFactor_.has_value()) {\n        solutionPath.interpolate(pathSamplingFactor_.value() * solutionPath.getStateCount());\n    } else {\n        unsigned int n = 0;\n        const auto n1 {solutionPath.getStateCount() - 1};\n        for (size_t i = 0; i < n1; ++i) {\n            n += si_->getStateSpace()->validSegmentCount(solutionPath.getState(i), solutionPath.getState(i + 1));\n        }\n        solutionPath.interpolate(n);\n    }\n\n    // Debug\n    if (verbose_)\n    {\n        OMPL_INFORM(\"-------------------------------------------------------\");\n        OMPL_INFORM(\"Attempting to add %d states to roadmap\", solutionPath.getStateCount());\n        OMPL_INFORM(\"-------------------------------------------------------\");\n    }\n\n    // Try to add the start first, but don't force it\n    addStateToRoadmap(ptc, solutionPath.getState(0));\n\n#ifdef OMPL_THUNDER_DEBUG\n    visualizeStateCallback(solutionPath.getState(solutionPath.getStateCount() - 1), 3, sparseDelta_);\n#endif\n\n    // Add solution states to SPARSdb one by one ---------------------------\n\n    // Track which nodes we've already tried to add\n    std::vector<std::size_t> addedStateIDs;\n    // Track which nodes we will attempt to use as connectivity states\n    std::vector<std::size_t> connectivityStateIDs;\n    // std::vector<base::State*> connectivityStates;\n\n    double distanceFromLastState = 0;\n\n    std::size_t lastStateID = 0;  // track the id in the solutionPath of the last state\n\n    for (std::size_t i = 1; i < solutionPath.getStateCount();\n         ++i)  // skip 0 and last because those are start/goal and are already added\n    {\n        distanceFromLastState = si_->distance(solutionPath.getState(i), solutionPath.getState(lastStateID));\n\n        if (verbose_ && false)\n        {\n            OMPL_INFORM(\"Index %d at distance %f from last state \", i, distanceFromLastState);\n        }\n\n        if (distanceFromLastState >= sparseDelta_ * spacingFactor)\n        {\n            if (verbose_)\n            {\n                OMPL_INFORM(\"Adding state %d of %d\", i, solutionPath.getStateCount());\n            }\n\n// Show the candidate state in Rviz for path insertion of GUARDS\n#ifdef OMPL_THUNDER_DEBUG\n            visualizeStateCallback(solutionPath.getState(i), 1, sparseDelta_);\n#endif\n\n            // Add a single state to the roadmap\n            if (!addStateToRoadmap(ptc, solutionPath.getState(i)))\n            {\n                if (verbose_)\n                {\n                    OMPL_INFORM(\"Last state added to roadmap failed \");\n                }\n            }\n\n            // Now figure out midpoint state between lastState and i\n            std::size_t midStateID = (i - lastStateID) / 2 + lastStateID;\n            connectivityStateIDs.push_back(midStateID);\n\n            double distA = si_->distance(solutionPath.getState(lastStateID), solutionPath.getState(midStateID));\n            double distB = si_->distance(solutionPath.getState(i), solutionPath.getState(midStateID));\n            double diff = distA - distB;\n            if ((diff < std::numeric_limits<double>::epsilon()) && (-diff < std::numeric_limits<double>::epsilon()))\n                if (verbose_)\n                    OMPL_WARN(\"DISTANCES ARE DIFFERENT \");\n\n            // Save this state as the new last state\n            lastStateID = i;\n            // Remember which nodes we've already added / attempted to add\n            addedStateIDs.push_back(midStateID);\n            addedStateIDs.push_back(i);\n        }\n        // Close up if it doesn't do it automatically\n        else if (i == solutionPath.getStateCount() - 1)\n        {\n            if (verbose_)\n                OMPL_INFORM(\"Last state - do special midpoint\");\n\n            // Now figure out midpoint state between lastState and i\n            std::size_t midStateID = (i - lastStateID) / 2 + lastStateID;\n            connectivityStateIDs.push_back(midStateID);\n            addedStateIDs.push_back(midStateID);\n            if (verbose_)\n                OMPL_INFORM(\"Mid state is %d\", midStateID);\n        }\n    }\n\n    // Attempt to add the goal directly\n    addStateToRoadmap(ptc, solutionPath.getState(solutionPath.getStateCount() - 1));\n\n    if (verbose_)\n    {\n        OMPL_INFORM(\"-------------------------------------------------------\");\n        OMPL_INFORM(\"-------------------------------------------------------\");\n        OMPL_INFORM(\"Adding connectivity states ----------------------------\");\n        OMPL_INFORM(\"-------------------------------------------------------\");\n        OMPL_INFORM(\"-------------------------------------------------------\");\n    }\n\n    for (std::size_t i = 0; i < connectivityStateIDs.size(); ++i)\n    {\n        base::State *connectivityState = solutionPath.getState(connectivityStateIDs[i]);\n\n        if (verbose_)\n        {\n            OMPL_INFORM(\"Adding connectvity state \", i);\n        }\n\n#ifdef OMPL_THUNDER_DEBUG\n        // Show the candidate state in Rviz for path insertion of BRIDGES (CONNECTIVITY)\n        visualizeStateCallback(connectivityState, 2, sparseDelta_);\n        sleep(0.5);\n#endif\n\n        // Add a single state to the roadmap\n        addStateToRoadmap(ptc, connectivityState);\n    }\n\n    // Add remaining states at random\n    if (verbose_)\n    {\n        OMPL_INFORM(\"-------------------------------------------------------\");\n        OMPL_INFORM(\"-------------------------------------------------------\");\n        OMPL_INFORM(\"Adding remaining states randomly ----------------------\");\n        OMPL_INFORM(\"-------------------------------------------------------\");\n        OMPL_INFORM(\"-------------------------------------------------------\");\n    }\n\n    // Create a vector of shuffled indexes\n    std::vector<std::size_t> shuffledIDs;\n    std::size_t usedIDTracker = 0;\n    for (std::size_t i = 1; i < solutionPath.getStateCount(); ++i)  // skip 0 because start already added\n    {\n        // Check if we've already used this id\n        if (usedIDTracker < addedStateIDs.size() && i == addedStateIDs[usedIDTracker])\n        {\n            // skip this id\n            usedIDTracker++;\n            continue;\n        }\n\n        shuffledIDs.push_back(i);  // 1 2 3...\n    }\n\n    std::shuffle(shuffledIDs.begin(), shuffledIDs.end(), std::mt19937(std::random_device()()));\n\n    // Add each state randomly\n    for (unsigned long shuffledID : shuffledIDs)\n    {\n#ifdef OMPL_THUNDER_DEBUG\n        visualizeStateCallback(solutionPath.getState(shuffledIDs[i]), 1, sparseDelta_);\n#endif\n\n        // Add a single state to the roadmap\n        addStateToRoadmap(ptc, solutionPath.getState(shuffledID));\n    }\n\n    bool benchmarkLogging = false;\n    if (benchmarkLogging)\n    {\n        OMPL_DEBUG(\"ompl::geometric::SPARSdb: Benchmark logging enabled (slower)\");\n\n        // Return the result of inserting into database, if applicable\n        return checkStartGoalConnection(solutionPath);\n    }\n\n    return true;\n}\n\nbool ompl::geometric::SPARSdb::checkStartGoalConnection(ompl::geometric::PathGeometric &solutionPath)\n{\n    // Make sure path has states\n    if (solutionPath.getStateCount() < 2)\n    {\n        OMPL_ERROR(\"Not enough states (< 2) in the solutionPath\");\n        return false;\n    }\n\n    bool error = false;\n    CandidateSolution candidateSolution;\n    do\n    {\n        base::State *actualStart = solutionPath.getState(0);\n        base::State *actualGoal = solutionPath.getState(solutionPath.getStateCount() - 1);\n\n        /* The whole neighborhood set which has been most recently computed */\n        std::vector<Vertex> graphNeighborhood;\n        /* The visible neighborhood set which has been most recently computed */\n        std::vector<Vertex> visibleNeighborhood;\n\n        // Get start vertex\n        findGraphNeighbors(actualStart, graphNeighborhood, visibleNeighborhood);\n        if (!visibleNeighborhood.size())\n        {\n            OMPL_ERROR(\"No vertexes found near start\");\n            error = true;\n            break;\n        }\n        Vertex closeStart = visibleNeighborhood[0];\n\n        // Get goal vertex\n        findGraphNeighbors(actualGoal, graphNeighborhood, visibleNeighborhood);\n        if (!visibleNeighborhood.size())\n        {\n            OMPL_ERROR(\"No vertexes found near goal\");\n            error = true;\n            break;\n        }\n        Vertex closeGoal = visibleNeighborhood[0];\n\n        // Check if connected\n        if (false)\n            if (!sameComponent(closeStart, closeGoal))\n            {\n                OMPL_ERROR(\"Start and goal are not connected!\");\n                error = true;\n                break;\n            }\n\n        // Get new path from start to goal\n        std::vector<Vertex> vertexPath;\n        if (!constructSolution(closeStart, closeGoal, vertexPath))\n        {\n            OMPL_ERROR(\"Unable to find path from start to goal - perhaps because of new obstacles\");\n            error = true;\n            break;\n        }\n\n        // Convert to PathGeometric\n        bool disableCollisionWarning = true;  // this is just for benchmarking purposes\n        if (!convertVertexPathToStatePath(vertexPath, actualStart, actualGoal, candidateSolution,\n                                          disableCollisionWarning))\n        {\n            OMPL_ERROR(\"Unable to convert to state path\");\n            error = true;\n            break;\n        }\n    } while (false);\n\n    // Check distance of new path from old path\n    double originalLength = solutionPath.length();\n\n    OMPL_DEBUG(\"Results of attempting to make insertion in SPARSdb \");\n    OMPL_DEBUG(\"-------------------------------------------------------\");\n    OMPL_DEBUG(\"Original length:    %f\", originalLength);\n\n    if (error)\n    {\n        OMPL_ERROR(\"UNABLE TO GET PATH\");\n\n        // Record this for plotting\n        numPathInsertionFailures_++;\n    }\n    else\n    {\n        double newLength = candidateSolution.getGeometricPath().length();\n        double percentIncrease = 100 - originalLength / newLength * 100;\n        OMPL_DEBUG(\"New length:        %f\", newLength);\n        OMPL_DEBUG(\"Percent increase:  %f %%\", percentIncrease);\n        if(percentIncrease < 0) {\n          solutionPath = candidateSolution.getGeometricPath();\n        }\n    }\n\n    return !error;  // return true if it inserted correctly\n}\n\nbool ompl::geometric::SPARSdb::addStateToRoadmap(const base::PlannerTerminationCondition &ptc, base::State *newState)\n{\n    bool stateAdded = false;\n    // Check that the query vertex is initialized (used for internal nearest neighbor searches)\n    checkQueryStateInitialization();\n\n    // Deep copy\n    base::State *qNew = si_->cloneState(newState);\n    base::State *workState = si_->allocState();\n\n    /* The whole neighborhood set which has been most recently computed */\n    std::vector<Vertex> graphNeighborhood;\n    std::vector<Vertex> gnbhd;\n\n    /* The visible neighborhood set which has been most recently computed */\n    std::vector<Vertex> visibleNeighborhood;\n    std::vector<Vertex> vnbhd;\n\n    ++iterations_;\n\n    if (denseRoadmap_) {\n        //this added call to findGraphNeighbors is very inexpensive when granularity is small enough (which it is meant to be).\n        findGraphNeighbors(qNew, gnbhd, vnbhd, granularity_);\n        // if roadmap has only one connected component when we try to add a node, skip the expensive attempt to add it as a connectivity node.\n        const bool check_if_node_is_connecting {check_connected_components_ && getNumConnectedComponents() > 1};\n        if (!check_if_node_is_connecting && vnbhd.size()) {\n            OMPL_DEBUG(\"NOT adding state!\");\n            return false;\n        }\n        OMPL_DEBUG(\"Trying to add state! CCs: %d\", getNumConnectedComponents());\n    }\n\n    //@TODO - Ramy: Test if creating another nbhd to seperate recall from connectivity has positive effects.\n    findGraphNeighbors(qNew, graphNeighborhood, visibleNeighborhood);\n    if (verbose_)\n    {\n        OMPL_INFORM(\" graph neighborhood: %d | visible neighborhood: %d\", graphNeighborhood.size(),\n                    visibleNeighborhood.size());\n\n        foreach (Vertex v, visibleNeighborhood)\n        {\n            OMPL_INFORM(\"Visible neighbor is vertex %f with distance %f \", v, si_->distance(qNew, stateProperty_[v]));\n        }\n    }\n\n    if (verbose_)\n        OMPL_INFORM(\" - checkAddCoverage() Are other nodes around it visible?\");\n    // Coverage criterion\n    if (vnbhd.size() || !checkAddCoverage(qNew,\n                          visibleNeighborhood))  // Always add a node if no other nodes around it are visible (GUARD)\n    {\n        if (verbose_)\n            OMPL_INFORM(\" -- checkAddConnectivity() Does this node connect neighboring nodes that are not connected? \");\n        // Connectivity criterion\n        if (!checkAddConnectivity(qNew, visibleNeighborhood))\n        {\n            if (verbose_)\n                OMPL_INFORM(\" --- checkAddInterface() Does this node's neighbor's need it to better connect them? \");\n            if (!checkAddInterface(qNew, graphNeighborhood, visibleNeighborhood)) // @TODO - Ramy: I think with the new changes this becomes unnecessary. Test without it and see.\n            {\n                if (verbose_)\n                    OMPL_INFORM(\" ---- Ensure SPARS asymptotic optimality\");\n                if (visibleNeighborhood.size() > 0)\n                {\n                    std::map<Vertex, base::State *> closeRepresentatives;\n                    if (verbose_)\n                        OMPL_INFORM(\" ----- findCloseRepresentatives()\");\n\n                    findCloseRepresentatives(workState, qNew, visibleNeighborhood[0], closeRepresentatives, ptc);\n                    if (verbose_)\n                        OMPL_INFORM(\"------ Found %d close representatives\", closeRepresentatives.size());\n\n                    for (auto &closeRepresentative : closeRepresentatives)\n                    {\n                        if (verbose_)\n                            OMPL_INFORM(\" ------ Looping through close representatives\");\n                        updatePairPoints(visibleNeighborhood[0], qNew, closeRepresentative.first,\n                                         closeRepresentative.second);\n                        updatePairPoints(closeRepresentative.first, closeRepresentative.second, visibleNeighborhood[0],\n                                         qNew);\n                    }\n                    if (verbose_)\n                        OMPL_INFORM(\" ------ checkAddPath()\");\n                    if (checkAddPath(visibleNeighborhood[0]))\n                    {\n                        if (verbose_)\n                        {\n                            OMPL_INFORM(\"nearest visible neighbor added \");\n                        }\n                    }\n\n                    for (auto &closeRepresentative : closeRepresentatives)\n                    {\n                        if (verbose_)\n                            OMPL_INFORM(\" ------- Looping through close representatives to add path\");\n                        checkAddPath(closeRepresentative.first);\n                        si_->freeState(closeRepresentative.second);\n                    }\n                    if (verbose_)\n                        OMPL_INFORM(\"------ Done with inner most loop \");\n                }\n            }\n            else  //  added for interface\n            {\n                stateAdded = true;\n            }\n        }\n        else  // added for connectivity\n        {\n            stateAdded = true;\n        }\n    }\n    else  // added for coverage\n    {\n        stateAdded = true;\n    }\n\n    if (!stateAdded)\n        ++consecutiveFailures_;\n\n    si_->freeState(workState);\n    si_->freeState(qNew);\n\n    return stateAdded;\n}\n\nvoid ompl::geometric::SPARSdb::checkQueryStateInitialization()\n{\n    if (boost::num_vertices(g_) < 1)\n    {\n        queryVertex_ = boost::add_vertex(g_);\n        stateProperty_[queryVertex_] = nullptr;\n    }\n}\n\nompl::base::PlannerStatus ompl::geometric::SPARSdb::solve(const base::PlannerTerminationCondition &)\n{\n    // Disabled\n    return base::PlannerStatus::TIMEOUT;\n}\n\nbool ompl::geometric::SPARSdb::checkAddCoverage(const base::State *qNew, std::vector<Vertex> &visibleNeighborhood)\n{\n    if (!denseRoadmap_ && visibleNeighborhood.size() > 0)\n        return false;\n    // No free paths means we add for coverage\n    if (verbose_)\n        OMPL_INFORM(\" --- Adding node for COVERAGE \");\n    Vertex v = addGuard(si_->cloneState(qNew), COVERAGE);\n\n    if (denseRoadmap_) {\n        for (const auto &neighbor : visibleNeighborhood) {\n            // If there's no edge between the two new states\n            // DTC: this should actually never happen - we just created the new vertex so\n            // why would it be connected to anything?\n            if (!boost::edge(v, neighbor, g_).second) {\n                connectGuards(v, neighbor);\n            }\n        }\n    }\n\n    if (verbose_)\n        OMPL_INFORM(\"       Added vertex %f\", v);\n\n    return true;\n}\n\nbool ompl::geometric::SPARSdb::checkAddConnectivity(const base::State *qNew, std::vector<Vertex> &visibleNeighborhood)\n{\n    // Identify visibile nodes around our new state that are unconnected (in different connected components)\n    // and connect them\n\n    std::vector<Vertex> statesInDiffConnectedComponents;  // links\n    Vertex newVertex {};\n\n    if (visibleNeighborhood.size() > 1)  // if less than 2 there is no way to find a pair of nodes in different connected components\n    {\n        // For each neighbor\n        for (std::size_t i = 0; i < visibleNeighborhood.size(); ++i)\n        {\n            // For each other neighbor\n            for (std::size_t j = i + 1; j < visibleNeighborhood.size(); ++j)\n            {\n                // If they are in different components\n                if (!sameComponent(visibleNeighborhood[i], visibleNeighborhood[j]))\n                {\n                    statesInDiffConnectedComponents.push_back(visibleNeighborhood[i]);\n                    statesInDiffConnectedComponents.push_back(visibleNeighborhood[j]);\n                }\n            }\n        }\n\n        // Were any diconnected states found?\n        if (statesInDiffConnectedComponents.size() > 0)\n        {\n            if (verbose_)\n                OMPL_INFORM(\" --- Adding node for CONNECTIVITY \");\n            // Add the node\n            newVertex = addGuard(si_->cloneState(qNew), CONNECTIVITY);\n\n            for (unsigned long statesInDiffConnectedComponent : statesInDiffConnectedComponents)\n            {\n                // If there's no edge between the two new states\n                // DTC: this should actually never happen - we just created the new vertex so\n                // why would it be connected to anything?\n                if (!boost::edge(newVertex, statesInDiffConnectedComponent, g_).second)\n                {\n                    // The components haven't been united by previous links\n                    if (!sameComponent(statesInDiffConnectedComponent, newVertex))\n                        connectGuards(newVertex, statesInDiffConnectedComponent);\n                }\n            }\n\n            return true;\n        }\n    }\n    return false;\n}\n\nbool ompl::geometric::SPARSdb::checkAddInterface(const base::State *qNew, std::vector<Vertex> &graphNeighborhood,\n                                                 std::vector<Vertex> &visibleNeighborhood)\n{\n    // If we have at least 2 neighbors\n    if (visibleNeighborhood.size() > 1)\n    {\n        // If the two closest nodes are also visible\n        if (graphNeighborhood[0] == visibleNeighborhood[0] && graphNeighborhood[1] == visibleNeighborhood[1])\n        {\n            // If our two closest neighbors don't share an edge\n            if (!boost::edge(visibleNeighborhood[0], visibleNeighborhood[1], g_).second)\n            {\n                // If they can be directly connected\n                if (si_->checkMotion(stateProperty_[visibleNeighborhood[0]], stateProperty_[visibleNeighborhood[1]]))\n                {\n                    // Connect them\n                    if (verbose_)\n                        OMPL_INFORM(\" ---   INTERFACE: directly connected nodes \");\n                    connectGuards(visibleNeighborhood[0], visibleNeighborhood[1]);\n                    // And report that we added to the roadmap\n                    resetFailures();\n                    // Report success\n                    return true;\n                }\n                else\n                {\n                    // Add the new node to the graph, to bridge the interface\n                    if (verbose_)\n                        OMPL_INFORM(\" --- Adding node for INTERFACE  \");\n                    Vertex v = addGuard(si_->cloneState(qNew), INTERFACE);\n                    connectGuards(v, visibleNeighborhood[0]);\n                    connectGuards(v, visibleNeighborhood[1]);\n                    if (verbose_)\n                        OMPL_INFORM(\" ---   INTERFACE: connected two neighbors through new interface node \");\n                    // Report success\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nbool ompl::geometric::SPARSdb::checkAddPath(Vertex v)\n{\n    bool spannerPropertyWasViolated = false;\n\n    std::vector<Vertex> rs;\n    foreach (Vertex r, boost::adjacent_vertices(v, g_))\n        rs.push_back(r);\n\n    /* Candidate x vertices as described in the method, filled by function computeX(). */\n    std::vector<Vertex> Xs;\n\n    /* Candidate v\" vertices as described in the method, filled by function computeVPP(). */\n    std::vector<Vertex> VPPs;\n\n    for (std::size_t i = 0; i < rs.size() && !spannerPropertyWasViolated; ++i)\n    {\n        Vertex r = rs[i];\n        computeVPP(v, r, VPPs);\n        foreach (Vertex rp, VPPs)\n        {\n            // First, compute the longest path through the graph\n            computeX(v, r, rp, Xs);\n            double rm_dist = 0.0;\n            foreach (Vertex rpp, Xs)\n            {\n                double tmp_dist = (si_->distance(stateProperty_[r], stateProperty_[v]) +\n                                   si_->distance(stateProperty_[v], stateProperty_[rpp])) /\n                                  2.0;\n                if (tmp_dist > rm_dist)\n                    rm_dist = tmp_dist;\n            }\n\n            InterfaceData &d = getData(v, r, rp);\n\n            // Then, if the spanner property is violated\n            if (rm_dist > stretchFactor_ * d.d_)\n            {\n                spannerPropertyWasViolated = true;  // Report that we added for the path\n                if (si_->checkMotion(stateProperty_[r], stateProperty_[rp]))\n                    connectGuards(r, rp);\n                else\n                {\n                    auto p(std::make_shared<PathGeometric>(si_));\n                    if (r < rp)\n                    {\n                        p->append(d.sigmaA_);\n                        p->append(d.pointA_);\n                        p->append(stateProperty_[v]);\n                        p->append(d.pointB_);\n                        p->append(d.sigmaB_);\n                    }\n                    else\n                    {\n                        p->append(d.sigmaB_);\n                        p->append(d.pointB_);\n                        p->append(stateProperty_[v]);\n                        p->append(d.pointA_);\n                        p->append(d.sigmaA_);\n                    }\n\n                    psimp_->reduceVertices(*p, 10);\n                    psimp_->shortcutPath(*p, 50);\n\n                    if (p->checkAndRepair(100).second)\n                    {\n                        Vertex prior = r;\n                        Vertex vnew;\n                        std::vector<base::State *> &states = p->getStates();\n\n                        foreach (base::State *st, states)\n                        {\n                            // no need to clone st, since we will destroy p; we just copy the pointer\n                            if (verbose_)\n                                OMPL_INFORM(\" --- Adding node for QUALITY\");\n                            vnew = addGuard(st, QUALITY);\n\n                            connectGuards(prior, vnew);\n                            prior = vnew;\n                        }\n                        // clear the states, so memory is not freed twice\n                        states.clear();\n                        connectGuards(prior, rp);\n                    }\n                }\n            }\n        }\n    }\n\n    if (!spannerPropertyWasViolated)\n    {\n        if (verbose_)\n        {\n            OMPL_INFORM(\" ------- Spanner property was NOT violated, SKIPPING\");\n        }\n    }\n\n    return spannerPropertyWasViolated;\n}\n\nvoid ompl::geometric::SPARSdb::resetFailures()\n{\n    consecutiveFailures_ = 0;\n}\n\nvoid ompl::geometric::SPARSdb::findGraphNeighbors(base::State *st, std::vector<Vertex> &graphNeighborhood,\n                                                  std::vector<Vertex> &visibleNeighborhood, std::optional<double> radius)\n{\n    visibleNeighborhood.clear();\n    stateProperty_[queryVertex_] = st;\n    if (!radius.has_value()) {\n        radius = sparseDelta_;\n    }\n    nn_->nearestR(queryVertex_, *radius, graphNeighborhood);\n    if (verbose_ && false)\n        OMPL_INFORM(\"Finding nearest nodes in NN tree within radius %f\", *radius);\n    stateProperty_[queryVertex_] = nullptr;\n\n    // Now that we got the neighbors from the NN, we must remove any we can't see\n    for (unsigned long i : graphNeighborhood)\n        if (si_->checkMotion(st, stateProperty_[i]))\n            visibleNeighborhood.push_back(i);\n}\n\nbool ompl::geometric::SPARSdb::findGraphNeighbors(const base::State *state, std::vector<Vertex> &graphNeighborhood, std::optional<double> radius)\n{\n    base::State *stateCopy = si_->cloneState(state);\n\n    if (!radius.has_value()) {\n        radius = sparseDelta_;\n    }\n    // Don't check for visibility\n    graphNeighborhood.clear();\n    stateProperty_[queryVertex_] = stateCopy;\n\n    // Double the range of sparseDelta_ up to 3 times until at least 1 neighbor is found\n    std::size_t expandNeighborhoodSearchAttempts = 3;\n    double neighborSearchRadius;\n    static const double EXPAND_NEIGHBORHOOD_RATE =\n        0.25;  // speed to which we look outside the original sparse delta neighborhood\n    for (std::size_t i = 0; i < expandNeighborhoodSearchAttempts; ++i)\n    {\n        neighborSearchRadius = *radius + i * EXPAND_NEIGHBORHOOD_RATE * (*radius);\n        if (verbose_)\n        {\n            OMPL_INFORM(\"-------------------------------------------------------\");\n            OMPL_INFORM(\"Attempt %d to find neighborhood at radius %f\", i + 1, neighborSearchRadius);\n            OMPL_INFORM(\"-------------------------------------------------------\");\n        }\n\n        nn_->nearestR(queryVertex_, neighborSearchRadius, graphNeighborhood);\n\n        // Check if at least one neighbor found\n        if (graphNeighborhood.size() > 0)\n            break;\n    }\n    stateProperty_[queryVertex_] = nullptr;\n\n    // Check if no neighbors found\n    if (!graphNeighborhood.size())\n    {\n        return false;\n    }\n    return true;\n}\n\nvoid ompl::geometric::SPARSdb::approachGraph(Vertex v)\n{\n    std::vector<Vertex> hold;\n    nn_->nearestR(v, sparseDelta_, hold);\n\n    std::vector<Vertex> neigh;\n    for (unsigned long i : hold)\n        if (si_->checkMotion(stateProperty_[v], stateProperty_[i]))\n            neigh.push_back(i);\n\n    foreach (Vertex vp, neigh)\n        connectGuards(v, vp);\n}\n\nompl::geometric::SPARSdb::Vertex ompl::geometric::SPARSdb::findGraphRepresentative(base::State *st)\n{\n    std::vector<Vertex> nbh;\n    stateProperty_[queryVertex_] = st;\n    nn_->nearestR(queryVertex_, sparseDelta_, nbh);\n    stateProperty_[queryVertex_] = nullptr;\n\n    if (verbose_)\n        OMPL_INFORM(\" ------- findGraphRepresentative found %d nearest neighbors of distance %f\", nbh.size(),\n                    sparseDelta_);\n\n    Vertex result = boost::graph_traits<Graph>::null_vertex();\n\n    for (std::size_t i = 0; i < nbh.size(); ++i)\n    {\n        if (verbose_)\n            OMPL_INFORM(\" -------- Checking motion of graph rep candidate %d\", i);\n        if (si_->checkMotion(st, stateProperty_[nbh[i]]))\n        {\n            if (verbose_)\n                OMPL_INFORM(\" --------- VALID \");\n            result = nbh[i];\n            break;\n        }\n    }\n    return result;\n}\n\nvoid ompl::geometric::SPARSdb::findCloseRepresentatives(base::State *workState, const base::State *qNew,\n                                                        const Vertex qRep,\n                                                        std::map<Vertex, base::State *> &closeRepresentatives,\n                                                        const base::PlannerTerminationCondition &ptc)\n{\n    // Properly clear the vector by also deleting previously sampled unused states\n    for (auto &closeRepresentative : closeRepresentatives)\n        si_->freeState(closeRepresentative.second);\n    closeRepresentatives.clear();\n\n    // denseDelta_ = 0.25 * sparseDelta_;\n    double maxExt = si_->getMaximumExtent();\n    sparseDelta_ = sparseDeltaFraction_ * maxExt;\n    denseDelta_ = denseDeltaFraction_ * maxExt;\n    nearSamplePoints_ /= 10;  // HACK - this makes it look for the same number of samples as dimensions\n\n    if (verbose_)\n        OMPL_INFORM(\" ----- nearSamplePoints: %f, denseDelta: %f\", nearSamplePoints_, denseDelta_);\n\n    // Then, begin searching the space around new potential state qNew\n    for (unsigned int i = 0; i < nearSamplePoints_ && ptc == false; ++i)\n    {\n        do\n        {\n            sampler_->sampleNear(workState, qNew, denseDelta_);\n\n#ifdef OMPL_THUNDER_DEBUG\n            visualizeStateCallback(workState, 3, sparseDelta_);\n            sleep(0.1);\n#endif\n\n            if (verbose_)\n            {\n                OMPL_INFORM(\" ------ findCloseRepresentatives sampled state \");\n\n                if (!si_->isValid(workState))\n                {\n                    OMPL_INFORM(\" ------ isValid \");\n                }\n                if (si_->distance(qNew, workState) > denseDelta_)\n                {\n                    OMPL_INFORM(\" ------ Distance too far \");\n                }\n                if (!si_->checkMotion(qNew, workState))\n                {\n                    OMPL_INFORM(\" ------ Motion invalid \");\n                }\n            }\n\n        } while ((!si_->isValid(workState) || si_->distance(qNew, workState) > denseDelta_ ||\n                  !si_->checkMotion(qNew, workState)) &&\n                 ptc == false);\n\n        // if we were not successful at sampling a desirable state, we are out of time\n        if (ptc == true)\n        {\n            if (verbose_)\n                OMPL_INFORM(\" ------ We are out of time \");\n            break;\n        }\n\n        if (verbose_)\n            OMPL_INFORM(\" ------ Find graph representative \");\n\n        // Compute who his graph neighbors are\n        Vertex representative = findGraphRepresentative(workState);\n\n        // Assuming this sample is actually seen by somebody (which he should be in all likelihood)\n        if (representative != boost::graph_traits<Graph>::null_vertex())\n        {\n            if (verbose_)\n                OMPL_INFORM(\" ------ Representative is not null \");\n\n            // If his representative is different than qNew\n            if (qRep != representative)\n            {\n                if (verbose_)\n                    OMPL_INFORM(\" ------ qRep != representative \");\n\n                // And we haven't already tracked this representative\n                if (closeRepresentatives.find(representative) == closeRepresentatives.end())\n                {\n                    if (verbose_)\n                        OMPL_INFORM(\" ------ Track the representative\");\n                    // Track the representativen\n                    closeRepresentatives[representative] = si_->cloneState(workState);\n                }\n            }\n            else\n            {\n                if (verbose_)\n                    OMPL_INFORM(\" ------ qRep == representative, no good \");\n            }\n        }\n        else\n        {\n            if (verbose_)\n                OMPL_INFORM(\" ------ Rep is null \");\n\n            // This guy can't be seen by anybody, so we should take this opportunity to add him\n            if (verbose_)\n                OMPL_INFORM(\" --- Adding node for COVERAGE\");\n            addGuard(si_->cloneState(workState), COVERAGE);\n\n            if (verbose_)\n            {\n                OMPL_INFORM(\" ------ STOP EFFORS TO ADD A DENSE PATH\");\n            }\n\n            // We should also stop our efforts to add a dense path\n            for (auto &closeRepresentative : closeRepresentatives)\n                si_->freeState(closeRepresentative.second);\n            closeRepresentatives.clear();\n            break;\n        }\n    }  // for loop\n}\n\nvoid ompl::geometric::SPARSdb::updatePairPoints(Vertex rep, const base::State *q, Vertex r, const base::State *s)\n{\n    // First of all, we need to compute all candidate r'\n    std::vector<Vertex> VPPs;\n    computeVPP(rep, r, VPPs);\n\n    // Then, for each pair Pv(r,r')\n    foreach (Vertex rp, VPPs)\n        // Try updating the pair info\n        distanceCheck(rep, q, r, s, rp);\n}\n\nvoid ompl::geometric::SPARSdb::computeVPP(Vertex v, Vertex vp, std::vector<Vertex> &VPPs)\n{\n    VPPs.clear();\n    foreach (Vertex cvpp, boost::adjacent_vertices(v, g_))\n        if (cvpp != vp)\n            if (!boost::edge(cvpp, vp, g_).second)\n                VPPs.push_back(cvpp);\n}\n\nvoid ompl::geometric::SPARSdb::computeX(Vertex v, Vertex vp, Vertex vpp, std::vector<Vertex> &Xs)\n{\n    Xs.clear();\n\n    foreach (Vertex cx, boost::adjacent_vertices(vpp, g_))\n        if (boost::edge(cx, v, g_).second && !boost::edge(cx, vp, g_).second)\n        {\n            InterfaceData &d = getData(v, vpp, cx);\n            if ((vpp < cx && d.pointA_) || (cx < vpp && d.pointB_))\n                Xs.push_back(cx);\n        }\n    Xs.push_back(vpp);\n}\n\nompl::geometric::SPARSdb::VertexPair ompl::geometric::SPARSdb::index(Vertex vp, Vertex vpp)\n{\n    if (vp < vpp)\n        return VertexPair(vp, vpp);\n    else if (vpp < vp)\n        return VertexPair(vpp, vp);\n    else\n        throw Exception(name_, \"Trying to get an index where the pairs are the same point!\");\n}\n\nompl::geometric::SPARSdb::InterfaceData &ompl::geometric::SPARSdb::getData(Vertex v, Vertex vp, Vertex vpp)\n{\n    return interfaceDataProperty_[v].interfaceHash[index(vp, vpp)];\n}\n\nvoid ompl::geometric::SPARSdb::distanceCheck(Vertex rep, const base::State *q, Vertex r, const base::State *s,\n                                             Vertex rp)\n{\n    // Get the info for the current representative-neighbors pair\n    InterfaceData &d = getData(rep, r, rp);\n\n    if (r < rp)  // FIRST points represent r (the guy discovered through sampling)\n    {\n        if (d.pointA_ == nullptr)  // If the point we're considering replacing (P_v(r,.)) isn't there\n            // Then we know we're doing better, so add it\n            d.setFirst(q, s, si_);\n        else  // Otherwise, he is there,\n        {\n            if (d.pointB_ == nullptr)  // But if the other guy doesn't exist, we can't compare.\n            {\n                // Should probably keep the one that is further away from rep?  Not known what to do in this case.\n                // TODO: is this not part of the algorithm?\n            }\n            else  // We know both of these points exist, so we can check some distances\n                if (si_->distance(q, d.pointB_) < si_->distance(d.pointA_, d.pointB_))\n                // Distance with the new point is good, so set it.\n                d.setFirst(q, s, si_);\n        }\n    }\n    else  // SECOND points represent r (the guy discovered through sampling)\n    {\n        if (d.pointB_ == nullptr)  // If the point we're considering replacing (P_V(.,r)) isn't there...\n            // Then we must be doing better, so add it\n            d.setSecond(q, s, si_);\n        else  // Otherwise, he is there\n        {\n            if (d.pointA_ == nullptr)  // But if the other guy doesn't exist, we can't compare.\n            {\n                // Should we be doing something cool here?\n            }\n            else if (si_->distance(q, d.pointA_) < si_->distance(d.pointB_, d.pointA_))\n                // Distance with the new point is good, so set it\n                d.setSecond(q, s, si_);\n        }\n    }\n\n    // Lastly, save what we have discovered\n    interfaceDataProperty_[rep].interfaceHash[index(r, rp)] = d;\n}\n\nvoid ompl::geometric::SPARSdb::abandonLists(base::State *st)\n{\n    stateProperty_[queryVertex_] = st;\n\n    std::vector<Vertex> hold;\n    nn_->nearestR(queryVertex_, sparseDelta_, hold);\n\n    stateProperty_[queryVertex_] = nullptr;\n\n    // For each of the vertices\n    foreach (Vertex v, hold)\n    {\n        foreach (VertexPair r, interfaceDataProperty_[v].interfaceHash | boost::adaptors::map_keys)\n            interfaceDataProperty_[v].interfaceHash[r].clear(si_);\n    }\n}\n\nompl::geometric::SPARSdb::Vertex ompl::geometric::SPARSdb::addGuard(base::State *state, GuardType type)\n{\n    Vertex m = boost::add_vertex(g_);\n    stateProperty_[m] = state;\n    colorProperty_[m] = type;\n\n    // assert(si_->isValid(state));\n    abandonLists(state);\n\n    disjointSets_.make_set(m);\n    nn_->add(m);\n    resetFailures();\n\n    if (verbose_)\n    {\n        OMPL_INFORM(\" ---- addGuard() of type %f\", type);\n    }\n#ifdef OMPL_THUNDER_DEBUG\n    visualizeStateCallback(state, 4, sparseDelta_);  // Candidate node has already (just) been added\n    sleep(0.1);\n#endif\n\n    return m;\n}\n\nvoid ompl::geometric::SPARSdb::connectGuards(Vertex v, Vertex vp)\n{\n    // OMPL_INFORM(\"connectGuards called ---------------------------------------------------------------- \");\n    assert(v <= getNumVertices());\n    assert(vp <= getNumVertices());\n\n    if (verbose_)\n    {\n        OMPL_INFORM(\" ------- connectGuards/addEdge: Connecting vertex %f to vertex %f\", v, vp);\n    }\n\n    // Create the new edge\n    Edge e = (boost::add_edge(v, vp, g_)).first;\n\n    // Add associated properties to the edge\n    edgeWeightProperty_[e] = costFunction(v, vp);  // TODO: use this value with astar\n    edgeCollisionStateProperty_[e] = NOT_CHECKED;\n\n    // Add the edge to the incrementeal connected components datastructure\n    disjointSets_.union_set(v, vp);\n\n// Debug in Rviz\n#ifdef OMPL_THUNDER_DEBUG\n    visualizeEdgeCallback(stateProperty_[v], stateProperty_[vp]);\n    sleep(0.8);\n#endif\n}\n\nbool ompl::geometric::SPARSdb::convertVertexPathToStatePath(std::vector<Vertex> &vertexPath,\n                                                            const base::State *actualStart,\n                                                            const base::State *actualGoal,\n                                                            CandidateSolution &candidateSolution,\n                                                            bool disableCollisionWarning)\n{\n    if (!vertexPath.size())\n        return false;\n\n    auto pathGeometric(std::make_shared<ompl::geometric::PathGeometric>(si_));\n    candidateSolution.isApproximate_ = false;  // assume path is valid\n\n    // Add original start if it is different than the first state\n    if (actualStart != stateProperty_[vertexPath.back()])\n    {\n        pathGeometric->append(actualStart);\n\n        // Add the edge status\n        // the edge from actualStart to start is always valid otherwise we would not have used that start\n        candidateSolution.edgeCollisionStatus_.push_back(FREE);\n    }\n\n    // Reverse the vertexPath and convert to state path\n    for (std::size_t i = vertexPath.size(); i > 0; --i)\n    {\n        pathGeometric->append(stateProperty_[vertexPath[i - 1]]);\n\n        // Add the edge status\n        if (i > 1)  // skip the last vertex (its reversed)\n        {\n            Edge thisEdge = boost::edge(vertexPath[i - 1], vertexPath[i - 2], g_).first;\n\n            // Check if any edges in path are not free (then it an approximate path)\n            if (edgeCollisionStateProperty_[thisEdge] == IN_COLLISION)\n            {\n                candidateSolution.isApproximate_ = true;\n                candidateSolution.edgeCollisionStatus_.push_back(IN_COLLISION);\n            }\n            else if (edgeCollisionStateProperty_[thisEdge] == NOT_CHECKED)\n            {\n                if (!disableCollisionWarning)\n                    OMPL_ERROR(\"A chosen path has an edge that has not been checked for collision. This should not \"\n                               \"happen\");\n                candidateSolution.edgeCollisionStatus_.push_back(NOT_CHECKED);\n            }\n            else\n            {\n                candidateSolution.edgeCollisionStatus_.push_back(FREE);\n            }\n        }\n    }\n\n    // Add original goal if it is different than the last state\n    if (actualGoal != stateProperty_[vertexPath.front()])\n    {\n        pathGeometric->append(actualGoal);\n\n        // Add the edge status\n        // the edge from actualGoal to goal is always valid otherwise we would not have used that goal\n        candidateSolution.edgeCollisionStatus_.push_back(FREE);\n    }\n\n    candidateSolution.path_ = pathGeometric;\n\n    return true;\n}\n\nvoid ompl::geometric::SPARSdb::getPlannerData(base::PlannerData &data) const\n{\n    Planner::getPlannerData(data);\n\n    // Explicitly add start and goal states:\n    for (unsigned long i : startM_)\n        data.addStartVertex(base::PlannerDataVertex(stateProperty_[i], (int)START));\n\n    for (unsigned long i : goalM_)\n        data.addGoalVertex(base::PlannerDataVertex(stateProperty_[i], (int)GOAL));\n\n    // I'm curious:\n    if (goalM_.size() > 0)\n    {\n        throw Exception(name_, \"SPARS2 has goal states?\");\n    }\n    if (startM_.size() > 0)\n    {\n        throw Exception(name_, \"SPARS2 has start states?\");\n    }\n\n    // If there are even edges here\n    if (boost::num_edges(g_) > 0)\n    {\n        // Adding edges and all other vertices simultaneously\n        foreach (const Edge e, boost::edges(g_))\n        {\n            const Vertex v1 = boost::source(e, g_);\n            const Vertex v2 = boost::target(e, g_);\n\n            // TODO save weights!\n            data.addEdge(base::PlannerDataVertex(stateProperty_[v1], (int)colorProperty_[v1]),\n                         base::PlannerDataVertex(stateProperty_[v2], (int)colorProperty_[v2]));\n\n            // OMPL_INFORM(\"Adding edge from vertex of type %d to vertex of type %d\", colorProperty_[v1],\n            // colorProperty_[v2]);\n        }\n    }\n    // else\n    //    OMPL_INFORM(\"%s: There are no edges in the graph!\", getName().c_str());\n\n    // Make sure to add edge-less nodes as well\n    foreach (const Vertex n, boost::vertices(g_))\n        if (boost::out_degree(n, g_) == 0)\n            data.addVertex(base::PlannerDataVertex(stateProperty_[n], (int)colorProperty_[n]));\n\n    data.properties[\"iterations INTEGER\"] = std::to_string(iterations_);\n}\n\nvoid ompl::geometric::SPARSdb::setPlannerData(const base::PlannerData &data, const bool validate)\n{\n    // Check that the query vertex is initialized (used for internal nearest neighbor searches)\n    checkQueryStateInitialization();\n\n    // Add all vertices\n    if (verbose_)\n    {\n        OMPL_INFORM(\"SPARS::setPlannerData: numVertices=%d\", data.numVertices());\n    }\n    OMPL_INFORM(\"Loading PlannerData into SPARSdb\");\n\n    std::vector<Vertex> idToVertex;\n\n    // Temp disable verbose mode for loading database\n    bool wasVerbose = verbose_;\n    verbose_ = false;\n\n    OMPL_INFORM(\"Loading vertices:\");\n    // Add the nodes to the graph\n    for (std::size_t vertexID = 0; vertexID < data.numVertices(); ++vertexID)\n    {\n        // Get the state from loaded planner data\n        const base::State *oldState = data.getVertex(vertexID).getState();\n        base::State *state = si_->cloneState(oldState);\n\n        // Get the tag, which in this application represents the vertex type\n        auto type = static_cast<GuardType>(data.getVertex(vertexID).getTag());\n\n        // ADD GUARD\n        idToVertex.push_back(addGuard(state, type));\n    }\n\n    OMPL_INFORM(\"Loading edges:\");\n    // Add the corresponding edges to the graph\n    std::vector<unsigned int> edgeList;\n    for (std::size_t fromVertex = 0; fromVertex < data.numVertices(); ++fromVertex)\n    {\n        edgeList.clear();\n\n        // Get the edges\n        data.getEdges(fromVertex, edgeList);  // returns num of edges\n\n        Vertex m = idToVertex[fromVertex];\n\n        // Process edges\n        for (unsigned int toVertex : edgeList)\n        {\n            Vertex n = idToVertex[toVertex];\n\n            // Add the edge to the graph\n            const base::Cost weight(0);\n            if (verbose_ && false)\n            {\n                OMPL_INFORM(\"    Adding edge from vertex id %d to id %d into edgeList\", fromVertex, toVertex);\n                OMPL_INFORM(\"      Vertex %d to %d\", m, n);\n            }\n            connectGuards(m, n);\n        }\n    }  // for\n\n    // Re-enable verbose mode, if necessary\n    verbose_ = wasVerbose;\n}\n\nvoid ompl::geometric::SPARSdb::clearEdgeCollisionStates()\n{\n    foreach (const Edge e, boost::edges(g_))\n        edgeCollisionStateProperty_[e] = NOT_CHECKED;  // each edge has an unknown state\n}\n"
        }
    ]
}