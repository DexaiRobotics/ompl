{
    "sourceFile": "src/ompl/control/src/PathControl.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1684419621497,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1684419635857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,9 +120,9 @@\n     controlDurations_ = other.controlDurations_;\n }\n \n ompl::base::Cost ompl::control::PathControl::cost(const base::OptimizationObjectivePtr &opt,\n-                                                  use_use_worst_motion_cost) const\n+                                                  const bool use_use_worst_motion_cost) const\n {\n     OMPL_ERROR(\"Error: Cost computation is only implemented for paths of type PathGeometric.\");\n     return opt->identityCost();\n }\n"
                }
            ],
            "date": 1684419621497,
            "name": "Commit-0",
            "content": "/*********************************************************************\n* Software License Agreement (BSD License)\n*\n*  Copyright (c) 2010, Rice University\n*  All rights reserved.\n*\n*  Redistribution and use in source and binary forms, with or without\n*  modification, are permitted provided that the following conditions\n*  are met:\n*\n*   * Redistributions of source code must retain the above copyright\n*     notice, this list of conditions and the following disclaimer.\n*   * Redistributions in binary form must reproduce the above\n*     copyright notice, this list of conditions and the following\n*     disclaimer in the documentation and/or other materials provided\n*     with the distribution.\n*   * Neither the name of the Rice University nor the names of its\n*     contributors may be used to endorse or promote products derived\n*     from this software without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*********************************************************************/\n\n/* Author: Ioan Sucan */\n\n#include \"ompl/control/PathControl.h\"\n#include \"ompl/control/spaces/DiscreteControlSpace.h\"\n#include \"ompl/geometric/PathGeometric.h\"\n#include \"ompl/base/samplers/UniformValidStateSampler.h\"\n#include \"ompl/base/OptimizationObjective.h\"\n#include \"ompl/util/Exception.h\"\n#include \"ompl/util/Console.h\"\n#include <numeric>\n#include <cmath>\n\nnamespace\n{\n    unsigned int getNumberOfDiscreteControls(const ompl::control::ControlSpace *cs)\n    {\n        if (cs->isCompound())\n        {\n            const auto *ccs = cs->as<ompl::control::CompoundControlSpace>();\n            unsigned int num = 0;\n            for (unsigned int i = 0; i < ccs->getSubspaceCount(); ++i)\n                num += getNumberOfDiscreteControls(ccs->getSubspace(i).get());\n\n            return num;\n        }\n        if (dynamic_cast<const ompl::control::DiscreteControlSpace *>(cs) != nullptr)\n            return 1;\n        return 0;\n    }\n\n    void printDiscreteControls(std::ostream &out, const ompl::control::ControlSpace *cs,\n                               const ompl::control::Control *c)\n    {\n        if (cs->isCompound())\n        {\n            const auto *ccs = cs->as<ompl::control::CompoundControlSpace>();\n            for (unsigned int i = 0; i < ccs->getSubspaceCount(); ++i)\n                printDiscreteControls(out, ccs->getSubspace(i).get(),\n                                      c->as<ompl::control::CompoundControl>()->components[i]);\n        }\n        else if (dynamic_cast<const ompl::control::DiscreteControlSpace *>(cs) != nullptr)\n            out << c->as<ompl::control::DiscreteControlSpace::ControlType>()->value << ' ';\n    }\n}\n\nompl::control::PathControl::PathControl(const base::SpaceInformationPtr &si) : base::Path(si)\n{\n    if (dynamic_cast<const SpaceInformation *>(si_.get()) == nullptr)\n        throw Exception(\"Cannot create a path with controls from a space that does not support controls\");\n}\n\nompl::control::PathControl::PathControl(const PathControl &path) : base::Path(path.si_)\n{\n    copyFrom(path);\n}\n\nompl::geometric::PathGeometric ompl::control::PathControl::asGeometric() const\n{\n    PathControl pc(*this);\n    pc.interpolate();\n    geometric::PathGeometric pg(si_);\n    pg.getStates().swap(pc.states_);\n    return pg;\n}\n\nompl::control::PathControl &ompl::control::PathControl::operator=(const PathControl &other)\n{\n    freeMemory();\n    si_ = other.si_;\n    copyFrom(other);\n    return *this;\n}\n\nvoid ompl::control::PathControl::copyFrom(const PathControl &other)\n{\n    states_.resize(other.states_.size());\n    controls_.resize(other.controls_.size());\n\n    for (unsigned int i = 0; i < states_.size(); ++i)\n        states_[i] = si_->cloneState(other.states_[i]);\n\n    const auto *si = static_cast<const SpaceInformation *>(si_.get());\n    for (unsigned int i = 0; i < controls_.size(); ++i)\n        controls_[i] = si->cloneControl(other.controls_[i]);\n\n    controlDurations_ = other.controlDurations_;\n}\n\nompl::base::Cost ompl::control::PathControl::cost(const base::OptimizationObjectivePtr &opt,\n                                                  use_use_worst_motion_cost) const\n{\n    OMPL_ERROR(\"Error: Cost computation is only implemented for paths of type PathGeometric.\");\n    return opt->identityCost();\n}\n\ndouble ompl::control::PathControl::length() const\n{\n    return std::accumulate(controlDurations_.begin(), controlDurations_.end(), 0.0);\n}\n\nvoid ompl::control::PathControl::print(std::ostream &out) const\n{\n    const auto *si = static_cast<const SpaceInformation *>(si_.get());\n    double res = si->getPropagationStepSize();\n    out << \"Control path with \" << states_.size() << \" states\" << std::endl;\n    for (unsigned int i = 0; i < controls_.size(); ++i)\n    {\n        out << \"At state \";\n        si_->printState(states_[i], out);\n        out << \"  apply control \";\n        si->printControl(controls_[i], out);\n        out << \"  for \" << (int)floor(0.5 + controlDurations_[i] / res) << \" steps\" << std::endl;\n    }\n    out << \"Arrive at state \";\n    si_->printState(states_[controls_.size()], out);\n    out << std::endl;\n}\n\nvoid ompl::control::PathControl::printAsMatrix(std::ostream &out) const\n{\n    if (states_.empty())\n        return;\n    const base::StateSpace *space(si_->getStateSpace().get());\n    const auto *si = static_cast<const SpaceInformation *>(si_.get());\n    const ControlSpace *cspace(si->getControlSpace().get());\n    std::vector<double> reals;\n\n    space->copyToReals(reals, states_[0]);\n    std::copy(reals.begin(), reals.end(), std::ostream_iterator<double>(out, \" \"));\n    if (controls_.empty())\n        return;\n\n    const ControlSpace *cs = static_cast<const SpaceInformation *>(si_.get())->getControlSpace().get();\n    unsigned int n = 0, m = getNumberOfDiscreteControls(cs);\n    double *val;\n    while ((val = cspace->getValueAddressAtIndex(controls_[0], n)) != nullptr)\n        ++n;\n    for (unsigned int i = 0; i < n + m; ++i)\n        out << \"0 \";\n    out << '0' << std::endl;\n    for (unsigned int i = 0; i < controls_.size(); ++i)\n    {\n        space->copyToReals(reals, states_[i + 1]);\n        std::copy(reals.begin(), reals.end(), std::ostream_iterator<double>(out, \" \"));\n        // print discrete controls\n        printDiscreteControls(out, cs, controls_[i]);\n        // print real-valued controls\n        for (unsigned int j = 0; j < n; ++j)\n            out << *cspace->getValueAddressAtIndex(controls_[i], j) << ' ';\n        out << controlDurations_[i] << std::endl;\n    }\n}\n\nvoid ompl::control::PathControl::interpolate()\n{\n    if (states_.size() <= controls_.size())\n    {\n        OMPL_ERROR(\"Interpolation not performed.  Number of states in the path should be strictly greater than the \"\n                   \"number of controls.\");\n        return;\n    }\n\n    const auto *si = static_cast<const SpaceInformation *>(si_.get());\n    std::vector<base::State *> newStates;\n    std::vector<Control *> newControls;\n    std::vector<double> newControlDurations;\n\n    double res = si->getPropagationStepSize();\n    for (unsigned int i = 0; i < controls_.size(); ++i)\n    {\n        auto steps = (int)floor(0.5 + controlDurations_[i] / res);\n        assert(steps >= 0);\n        if (steps <= 1)\n        {\n            newStates.push_back(states_[i]);\n            newControls.push_back(controls_[i]);\n            newControlDurations.push_back(controlDurations_[i]);\n            continue;\n        }\n        std::vector<base::State *> istates;\n        si->propagate(states_[i], controls_[i], steps, istates, true);\n        // last state is already in the non-interpolated path\n        if (!istates.empty())\n        {\n            si_->freeState(istates.back());\n            istates.pop_back();\n        }\n        newStates.push_back(states_[i]);\n        newStates.insert(newStates.end(), istates.begin(), istates.end());\n        newControls.push_back(controls_[i]);\n        newControlDurations.push_back(res);\n        for (int j = 1; j < steps; ++j)\n        {\n            newControls.push_back(si->cloneControl(controls_[i]));\n            newControlDurations.push_back(res);\n        }\n    }\n    newStates.push_back(states_[controls_.size()]);\n    states_.swap(newStates);\n    controls_.swap(newControls);\n    controlDurations_.swap(newControlDurations);\n}\n\nbool ompl::control::PathControl::check() const\n{\n    if (controls_.empty())\n    {\n        if (states_.size() == 1)\n            return si_->isValid(states_[0]);\n        return false;\n    }\n\n    bool valid = true;\n    const auto *si = static_cast<const SpaceInformation *>(si_.get());\n    double res = si->getPropagationStepSize();\n    base::State *next = si_->allocState();\n    for (unsigned int i = 0; valid && i < controls_.size(); ++i)\n    {\n        auto steps = (unsigned int)floor(0.5 + controlDurations_[i] / res);\n        if (!si->isValid(states_[i]) || si->propagateWhileValid(states_[i], controls_[i], steps, next) != steps ||\n            si->distance(next, states_[i + 1]) > std::numeric_limits<float>::epsilon())\n            valid = false;\n    }\n    si_->freeState(next);\n\n    return valid;\n}\n\nvoid ompl::control::PathControl::append(const base::State *state)\n{\n    states_.push_back(si_->cloneState(state));\n}\n\nvoid ompl::control::PathControl::append(const base::State *state, const Control *control, double duration)\n{\n    const auto *si = static_cast<const SpaceInformation *>(si_.get());\n    states_.push_back(si->cloneState(state));\n    controls_.push_back(si->cloneControl(control));\n    controlDurations_.push_back(duration);\n}\n\nvoid ompl::control::PathControl::random()\n{\n    freeMemory();\n    states_.resize(2);\n    controlDurations_.resize(1);\n    controls_.resize(1);\n\n    const auto *si = static_cast<const SpaceInformation *>(si_.get());\n    states_[0] = si->allocState();\n    states_[1] = si->allocState();\n    controls_[0] = si->allocControl();\n\n    base::StateSamplerPtr ss = si->allocStateSampler();\n    ss->sampleUniform(states_[0]);\n    ControlSamplerPtr cs = si->allocControlSampler();\n    cs->sample(controls_[0], states_[0]);\n    unsigned int steps = cs->sampleStepCount(si->getMinControlDuration(), si->getMaxControlDuration());\n    controlDurations_[0] = steps * si->getPropagationStepSize();\n    si->propagate(states_[0], controls_[0], steps, states_[1]);\n}\n\nbool ompl::control::PathControl::randomValid(unsigned int attempts)\n{\n    freeMemory();\n    states_.resize(2);\n    controlDurations_.resize(1);\n    controls_.resize(1);\n\n    const auto *si = static_cast<const SpaceInformation *>(si_.get());\n    states_[0] = si->allocState();\n    states_[1] = si->allocState();\n    controls_[0] = si->allocControl();\n\n    ControlSamplerPtr cs = si->allocControlSampler();\n    auto uvss(std::make_shared<base::UniformValidStateSampler>(si));\n    uvss->setNrAttempts(attempts);\n    bool ok = false;\n    for (unsigned int i = 0; i < attempts; ++i)\n        if (uvss->sample(states_[0]))\n        {\n            cs->sample(controls_[0], states_[0]);\n            unsigned int steps = cs->sampleStepCount(si->getMinControlDuration(), si->getMaxControlDuration());\n            controlDurations_[0] = steps * si->getPropagationStepSize();\n            if (si->propagateWhileValid(states_[0], controls_[0], steps, states_[1]) == steps)\n            {\n                ok = true;\n                break;\n            }\n        }\n\n    if (!ok)\n    {\n        freeMemory();\n        states_.clear();\n        controls_.clear();\n        controlDurations_.clear();\n    }\n    return ok;\n}\n\nvoid ompl::control::PathControl::freeMemory()\n{\n    for (auto &state : states_)\n        si_->freeState(state);\n    const auto *si = static_cast<const SpaceInformation *>(si_.get());\n    for (auto &control : controls_)\n        si->freeControl(control);\n}\n"
        }
    ]
}