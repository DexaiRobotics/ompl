{
    "sourceFile": "src/ompl/geometric/src/PathGeometric.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 9,
            "patches": [
                {
                    "date": 1684418520384,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1684418526437,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,9 +94,9 @@\n         return opt->identityCost();\n     // Compute path cost by accumulating the cost along the path\n     base::Cost cost(opt->initialCost(states_.front()));\n     for (std::size_t i = 1; i < states_.size(); ++i)\n-        cost = opt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i]));\n+        cost = mopt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i]));\n     cost = opt->combineCosts(cost, opt->terminalCost(states_.back()));\n     return cost;\n }\n \n"
                },
                {
                    "date": 1684418536910,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,9 +94,9 @@\n         return opt->identityCost();\n     // Compute path cost by accumulating the cost along the path\n     base::Cost cost(opt->initialCost(states_.front()));\n     for (std::size_t i = 1; i < states_.size(); ++i)\n-        cost = mopt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i]));\n+        cost = use_worstopt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i]));\n     cost = opt->combineCosts(cost, opt->terminalCost(states_.back()));\n     return cost;\n }\n \n"
                },
                {
                    "date": 1684418545022,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,9 +94,9 @@\n         return opt->identityCost();\n     // Compute path cost by accumulating the cost along the path\n     base::Cost cost(opt->initialCost(states_.front()));\n     for (std::size_t i = 1; i < states_.size(); ++i)\n-        cost = use_worstopt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i]));\n+        cost = use_worst_motion_cost_ ? opt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i]));\n     cost = opt->combineCosts(cost, opt->terminalCost(states_.back()));\n     return cost;\n }\n \n"
                },
                {
                    "date": 1684418557524,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,9 +94,10 @@\n         return opt->identityCost();\n     // Compute path cost by accumulating the cost along the path\n     base::Cost cost(opt->initialCost(states_.front()));\n     for (std::size_t i = 1; i < states_.size(); ++i)\n-        cost = use_worst_motion_cost_ ? opt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i]));\n+        cost = use_worst_motion_cost_ ? opt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i])) :\n+                                        opt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i]));\n     cost = opt->combineCosts(cost, opt->terminalCost(states_.back()));\n     return cost;\n }\n \n"
                },
                {
                    "date": 1684418686749,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,9 +94,9 @@\n         return opt->identityCost();\n     // Compute path cost by accumulating the cost along the path\n     base::Cost cost(opt->initialCost(states_.front()));\n     for (std::size_t i = 1; i < states_.size(); ++i)\n-        cost = use_worst_motion_cost_ ? opt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i])) :\n+        cost = use_worst_motion_cost_ ? opt->worseCost(cost, opt->motionCost(states_[i - 1], states_[i])) :\n                                         opt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i]));\n     cost = opt->combineCosts(cost, opt->terminalCost(states_.back()));\n     return cost;\n }\n"
                },
                {
                    "date": 1684418704200,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,9 +96,9 @@\n     base::Cost cost(opt->initialCost(states_.front()));\n     for (std::size_t i = 1; i < states_.size(); ++i)\n         cost = use_worst_motion_cost_ ? opt->worseCost(cost, opt->motionCost(states_[i - 1], states_[i])) :\n                                         opt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i]));\n-    cost = opt->combineCosts(cost, opt->terminalCost(states_.back()));\n+    cost = use_worst_motion_cost_ ?  : opt->combineCosts(cost, opt->terminalCost(states_.back()));\n     return cost;\n }\n \n double ompl::geometric::PathGeometric::length() const\n"
                },
                {
                    "date": 1684418714687,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,9 +96,10 @@\n     base::Cost cost(opt->initialCost(states_.front()));\n     for (std::size_t i = 1; i < states_.size(); ++i)\n         cost = use_worst_motion_cost_ ? opt->worseCost(cost, opt->motionCost(states_[i - 1], states_[i])) :\n                                         opt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i]));\n-    cost = use_worst_motion_cost_ ?  : opt->combineCosts(cost, opt->terminalCost(states_.back()));\n+    cost = use_worst_motion_cost_ ? opt->combineCosts(cost, opt->terminalCost(states_.back())) :\n+                                    opt->combineCosts(cost, opt->terminalCost(states_.back()));\n     return cost;\n }\n \n double ompl::geometric::PathGeometric::length() const\n"
                },
                {
                    "date": 1684418721874,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,9 +96,9 @@\n     base::Cost cost(opt->initialCost(states_.front()));\n     for (std::size_t i = 1; i < states_.size(); ++i)\n         cost = use_worst_motion_cost_ ? opt->worseCost(cost, opt->motionCost(states_[i - 1], states_[i])) :\n                                         opt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i]));\n-    cost = use_worst_motion_cost_ ? opt->combineCosts(cost, opt->terminalCost(states_.back())) :\n+    cost = use_worst_motion_cost_ ? opt->worseCost(cost, opt->terminalCost(states_.back())) :\n                                     opt->combineCosts(cost, opt->terminalCost(states_.back()));\n     return cost;\n }\n \n"
                },
                {
                    "date": 1684418973093,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,9 +87,9 @@\n     for (auto &state : states_)\n         si_->freeState(state);\n }\n \n-ompl::base::Cost ompl::geometric::PathGeometric::cost(const base::OptimizationObjectivePtr &opt, const bool use_) const\n+ompl::base::Cost ompl::geometric::PathGeometric::cost(const base::OptimizationObjectivePtr &opt, const bool use_w) const\n {\n     if (states_.empty())\n         return opt->identityCost();\n     // Compute path cost by accumulating the cost along the path\n"
                }
            ],
            "date": 1684418520384,
            "name": "Commit-0",
            "content": "/*********************************************************************\n* Software License Agreement (BSD License)\n*\n*  Copyright (c) 2008, Willow Garage, Inc.\n*  All rights reserved.\n*\n*  Redistribution and use in source and binary forms, with or without\n*  modification, are permitted provided that the following conditions\n*  are met:\n*\n*   * Redistributions of source code must retain the above copyright\n*     notice, this list of conditions and the following disclaimer.\n*   * Redistributions in binary form must reproduce the above\n*     copyright notice, this list of conditions and the following\n*     disclaimer in the documentation and/or other materials provided\n*     with the distribution.\n*   * Neither the name of the Willow Garage nor the names of its\n*     contributors may be used to endorse or promote products derived\n*     from this software without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*********************************************************************/\n\n/* Author: Ioan Sucan */\n\n#include \"ompl/geometric/PathGeometric.h\"\n#include \"ompl/base/samplers/UniformValidStateSampler.h\"\n#include \"ompl/base/OptimizationObjective.h\"\n#include \"ompl/base/ScopedState.h\"\n#include <algorithm>\n#include <cmath>\n#include <limits>\n#include <boost/math/constants/constants.hpp>\n\nompl::geometric::PathGeometric::PathGeometric(const PathGeometric &path) : base::Path(path.si_)\n{\n    copyFrom(path);\n}\n\nompl::geometric::PathGeometric::PathGeometric(const base::SpaceInformationPtr &si, const base::State *state)\n  : base::Path(si)\n{\n    states_.resize(1);\n    states_[0] = si_->cloneState(state);\n}\n\nompl::geometric::PathGeometric::PathGeometric(const base::SpaceInformationPtr &si, const base::State *state1,\n                                              const base::State *state2)\n  : base::Path(si)\n{\n    states_.resize(2);\n    states_[0] = si_->cloneState(state1);\n    states_[1] = si_->cloneState(state2);\n}\n\nompl::geometric::PathGeometric &ompl::geometric::PathGeometric::operator=(const PathGeometric &other)\n{\n    if (this != &other)\n    {\n        freeMemory();\n        si_ = other.si_;\n        copyFrom(other);\n    }\n    return *this;\n}\n\nvoid ompl::geometric::PathGeometric::copyFrom(const PathGeometric &other)\n{\n    states_.resize(other.states_.size());\n    for (unsigned int i = 0; i < states_.size(); ++i)\n        states_[i] = si_->cloneState(other.states_[i]);\n}\n\nvoid ompl::geometric::PathGeometric::freeMemory()\n{\n    for (auto &state : states_)\n        si_->freeState(state);\n}\n\nompl::base::Cost ompl::geometric::PathGeometric::cost(const base::OptimizationObjectivePtr &opt) const\n{\n    if (states_.empty())\n        return opt->identityCost();\n    // Compute path cost by accumulating the cost along the path\n    base::Cost cost(opt->initialCost(states_.front()));\n    for (std::size_t i = 1; i < states_.size(); ++i)\n        cost = opt->combineCosts(cost, opt->motionCost(states_[i - 1], states_[i]));\n    cost = opt->combineCosts(cost, opt->terminalCost(states_.back()));\n    return cost;\n}\n\ndouble ompl::geometric::PathGeometric::length() const\n{\n    double L = 0.0;\n    for (unsigned int i = 1; i < states_.size(); ++i)\n        L += si_->distance(states_[i - 1], states_[i]);\n    return L;\n}\n\ndouble ompl::geometric::PathGeometric::clearance() const\n{\n    double c = 0.0;\n    for (auto state : states_)\n        c += si_->getStateValidityChecker()->clearance(state);\n    if (states_.empty())\n        c = std::numeric_limits<double>::infinity();\n    else\n        c /= (double)states_.size();\n    return c;\n}\n\ndouble ompl::geometric::PathGeometric::smoothness() const\n{\n    double s = 0.0;\n    if (states_.size() > 2)\n    {\n        double a = si_->distance(states_[0], states_[1]);\n        for (unsigned int i = 2; i < states_.size(); ++i)\n        {\n            // view the path as a sequence of segments, and look at the triangles it forms:\n            //          s1\n            //          /\\          s4\n            //      a  /  \\ b       |\n            //        /    \\        |\n            //       /......\\_______|\n            //     s0    c   s2     s3\n            //\n            // use Pythagoras generalized theorem to find the cos of the angle between segments a and b\n            double b = si_->distance(states_[i - 1], states_[i]);\n            double c = si_->distance(states_[i - 2], states_[i]);\n            double acosValue = (a * a + b * b - c * c) / (2.0 * a * b);\n\n            if (acosValue > -1.0 && acosValue < 1.0)\n            {\n                // the smoothness is actually the outside angle of the one we compute\n                double angle = (boost::math::constants::pi<double>() - acos(acosValue));\n\n                // and we normalize by the length of the segments\n                double k = 2.0 * angle / (a + b);\n                s += k * k;\n            }\n            a = b;\n        }\n    }\n    return s;\n}\n\nbool ompl::geometric::PathGeometric::check() const\n{\n    // make sure state validity checker is set\n    if (!si_->isSetup())\n        si_->setup();\n\n    bool result = true;\n    if (states_.size() > 0)\n    {\n        if (si_->isValid(states_[0]))\n        {\n            int last = states_.size() - 1;\n            for (int j = 0; result && j < last; ++j)\n                if (!si_->checkMotion(states_[j], states_[j + 1]))\n                    result = false;\n        }\n        else\n            result = false;\n    }\n\n    return result;\n}\n\nvoid ompl::geometric::PathGeometric::print(std::ostream &out) const\n{\n    out << \"Geometric path with \" << states_.size() << \" states\" << std::endl;\n    for (auto state : states_)\n        si_->printState(state, out);\n    out << std::endl;\n}\nvoid ompl::geometric::PathGeometric::printAsMatrix(std::ostream &out) const\n{\n    const base::StateSpace *space(si_->getStateSpace().get());\n    std::vector<double> reals;\n    for (auto state : states_)\n    {\n        space->copyToReals(reals, state);\n        std::copy(reals.begin(), reals.end(), std::ostream_iterator<double>(out, \" \"));\n        out << std::endl;\n    }\n    out << std::endl;\n}\n\nstd::pair<bool, bool> ompl::geometric::PathGeometric::checkAndRepair(unsigned int attempts)\n{\n    if (states_.empty())\n        return std::make_pair(true, true);\n    if (states_.size() == 1)\n    {\n        bool result = si_->isValid(states_[0]);\n        return std::make_pair(result, result);\n    }\n\n    // a path with invalid endpoints cannot be fixed; planners should not return such paths anyway\n    const int n1 = states_.size() - 1;\n    if (!si_->isValid(states_[0]) || !si_->isValid(states_[n1]))\n        return std::make_pair(false, false);\n\n    base::State *temp = nullptr;\n    base::UniformValidStateSampler *uvss = nullptr;\n    bool result = true;\n\n    for (int i = 1; i < n1; ++i)\n        if (!si_->checkMotion(states_[i - 1], states_[i]) ||\n            // the penultimate state in the path needs an additional check:\n            // the motion between that state and the last state needs to be\n            // valid as well since we cannot change the last state.\n            (i == n1 - 1 && !si_->checkMotion(states_[i], states_[i + 1])))\n        {\n            // we now compute a state around which to sample\n            if (!temp)\n                temp = si_->allocState();\n            if (!uvss)\n            {\n                uvss = new base::UniformValidStateSampler(si_.get());\n                uvss->setNrAttempts(attempts);\n            }\n\n            // and a radius of sampling around that state\n            double radius = 0.0;\n\n            if (si_->isValid(states_[i]))\n            {\n                si_->copyState(temp, states_[i]);\n                radius = si_->distance(states_[i - 1], states_[i]);\n            }\n            else\n            {\n                unsigned int nextValid = n1 - 1;\n                for (int j = i + 1; j < n1; ++j)\n                    if (si_->isValid(states_[j]))\n                    {\n                        nextValid = j;\n                        break;\n                    }\n                // we know nextValid will be initialised because n1 - 1 is certainly valid.\n                si_->getStateSpace()->interpolate(states_[i - 1], states_[nextValid], 0.5, temp);\n                radius = std::max(si_->distance(states_[i - 1], temp), si_->distance(states_[i - 1], states_[i]));\n            }\n\n            bool success = false;\n\n            for (unsigned int a = 0; a < attempts; ++a)\n                if (uvss->sampleNear(states_[i], temp, radius))\n                {\n                    if (si_->checkMotion(states_[i - 1], states_[i]) &&\n                        // the penultimate state needs an additional check\n                        // (see comment at the top of outermost for-loop)\n                        (i < n1 - 1 || si_->checkMotion(states_[i], states_[i + 1])))\n                    {\n                        success = true;\n                        break;\n                    }\n                }\n                else\n                    break;\n            if (!success)\n            {\n                result = false;\n                break;\n            }\n        }\n\n    // free potentially allocated memory\n    if (temp)\n        si_->freeState(temp);\n    bool originalValid = uvss == nullptr;\n    if (uvss)\n        delete uvss;\n\n    return std::make_pair(originalValid, result);\n}\n\nvoid ompl::geometric::PathGeometric::subdivide()\n{\n    if (states_.size() < 2)\n        return;\n    std::vector<base::State *> newStates(1, states_[0]);\n    for (unsigned int i = 1; i < states_.size(); ++i)\n    {\n        base::State *temp = si_->allocState();\n        si_->getStateSpace()->interpolate(newStates.back(), states_[i], 0.5, temp);\n        newStates.push_back(temp);\n        newStates.push_back(states_[i]);\n    }\n    states_.swap(newStates);\n}\n\nvoid ompl::geometric::PathGeometric::interpolate()\n{\n    std::vector<base::State *> newStates;\n    const int segments = states_.size() - 1;\n\n    for (int i = 0; i < segments; ++i)\n    {\n        base::State *s1 = states_[i];\n        base::State *s2 = states_[i + 1];\n\n        newStates.push_back(s1);\n        unsigned int n = si_->getStateSpace()->validSegmentCount(s1, s2);\n\n        std::vector<base::State *> block;\n        si_->getMotionStates(s1, s2, block, n - 1, false, true);\n        newStates.insert(newStates.end(), block.begin(), block.end());\n    }\n    newStates.push_back(states_[segments]);\n    states_.swap(newStates);\n}\n\nvoid ompl::geometric::PathGeometric::interpolate(unsigned int requestCount)\n{\n    if (requestCount < states_.size() || states_.size() < 2)\n        return;\n\n    unsigned int count = requestCount;\n\n    // the remaining length of the path we need to add states along\n    double remainingLength = length();\n\n    // the new array of states this path will have\n    std::vector<base::State *> newStates;\n    const int n1 = states_.size() - 1;\n\n    for (int i = 0; i < n1; ++i)\n    {\n        base::State *s1 = states_[i];\n        base::State *s2 = states_[i + 1];\n\n        newStates.push_back(s1);\n\n        // the maximum number of states that can be added on the current motion (without its endpoints)\n        // such that we can at least fit the remaining states\n        int maxNStates = count + i - states_.size();\n\n        if (maxNStates > 0)\n        {\n            // compute an approximate number of states the following segment needs to contain; this includes endpoints\n            double segmentLength = si_->distance(s1, s2);\n            int ns =\n                i + 1 == n1 ? maxNStates + 2 : (int)floor(0.5 + (double)count * segmentLength / remainingLength) + 1;\n\n            // if more than endpoints are needed\n            if (ns > 2)\n            {\n                ns -= 2;  // subtract endpoints\n\n                // make sure we don't add too many states\n                if (ns > maxNStates)\n                    ns = maxNStates;\n\n                // compute intermediate states\n                std::vector<base::State *> block;\n                si_->getMotionStates(s1, s2, block, ns, false, true);\n                newStates.insert(newStates.end(), block.begin(), block.end());\n            }\n            else\n                ns = 0;\n\n            // update what remains to be done\n            count -= (ns + 1);\n            remainingLength -= segmentLength;\n        }\n        else\n            count--;\n    }\n\n    // add the last state\n    newStates.push_back(states_[n1]);\n    states_.swap(newStates);\n}\n\nvoid ompl::geometric::PathGeometric::reverse()\n{\n    std::reverse(states_.begin(), states_.end());\n}\n\nvoid ompl::geometric::PathGeometric::random()\n{\n    freeMemory();\n    states_.resize(2);\n    states_[0] = si_->allocState();\n    states_[1] = si_->allocState();\n    base::StateSamplerPtr ss = si_->allocStateSampler();\n    ss->sampleUniform(states_[0]);\n    ss->sampleUniform(states_[1]);\n}\n\nbool ompl::geometric::PathGeometric::randomValid(unsigned int attempts)\n{\n    freeMemory();\n    states_.resize(2);\n    states_[0] = si_->allocState();\n    states_[1] = si_->allocState();\n    base::UniformValidStateSampler uvss(si_.get());\n    uvss.setNrAttempts(attempts);\n    bool ok = false;\n    for (unsigned int i = 0; i < attempts; ++i)\n    {\n        if (uvss.sample(states_[0]) && uvss.sample(states_[1]))\n            if (si_->checkMotion(states_[0], states_[1]))\n            {\n                ok = true;\n                break;\n            }\n    }\n    if (!ok)\n    {\n        freeMemory();\n        states_.clear();\n    }\n    return ok;\n}\n\nvoid ompl::geometric::PathGeometric::overlay(const PathGeometric &over, unsigned int startIndex)\n{\n    if (startIndex > states_.size())\n        throw Exception(\"Index on path is out of bounds\");\n    const base::StateSpacePtr &sm = over.si_->getStateSpace();\n    const base::StateSpacePtr &dm = si_->getStateSpace();\n    bool copy = !states_.empty();\n    for (unsigned int i = 0, j = startIndex; i < over.states_.size(); ++i, ++j)\n    {\n        if (j == states_.size())\n        {\n            base::State *s = si_->allocState();\n            if (copy)\n                si_->copyState(s, states_.back());\n            states_.push_back(s);\n        }\n\n        copyStateData(dm, states_[j], sm, over.states_[i]);\n    }\n}\n\nvoid ompl::geometric::PathGeometric::append(const base::State *state)\n{\n    states_.push_back(si_->cloneState(state));\n}\n\nvoid ompl::geometric::PathGeometric::append(const PathGeometric &path)\n{\n    if (path.si_->getStateSpace()->getName() == si_->getStateSpace()->getName())\n    {\n        PathGeometric copy(path);\n        states_.insert(states_.end(), copy.states_.begin(), copy.states_.end());\n        copy.states_.clear();\n    }\n    else\n        overlay(path, states_.size());\n}\n\nvoid ompl::geometric::PathGeometric::prepend(const base::State *state)\n{\n    states_.insert(states_.begin(), si_->cloneState(state));\n}\n\nvoid ompl::geometric::PathGeometric::keepAfter(const base::State *state)\n{\n    int index = getClosestIndex(state);\n    if (index > 0)\n    {\n        if ((std::size_t)(index + 1) < states_.size())\n        {\n            double b = si_->distance(state, states_[index - 1]);\n            double a = si_->distance(state, states_[index + 1]);\n            if (b > a)\n                ++index;\n        }\n        for (int i = 0; i < index; ++i)\n            si_->freeState(states_[i]);\n        states_.erase(states_.begin(), states_.begin() + index);\n    }\n}\n\nvoid ompl::geometric::PathGeometric::keepBefore(const base::State *state)\n{\n    int index = getClosestIndex(state);\n    if (index >= 0)\n    {\n        if (index > 0 && (std::size_t)(index + 1) < states_.size())\n        {\n            double b = si_->distance(state, states_[index - 1]);\n            double a = si_->distance(state, states_[index + 1]);\n            if (b < a)\n                --index;\n        }\n        if ((std::size_t)(index + 1) < states_.size())\n        {\n            for (std::size_t i = index + 1; i < states_.size(); ++i)\n                si_->freeState(states_[i]);\n            states_.resize(index + 1);\n        }\n    }\n}\n\nint ompl::geometric::PathGeometric::getClosestIndex(const base::State *state) const\n{\n    if (states_.empty())\n        return -1;\n\n    int index = 0;\n    double min_d = si_->distance(states_[0], state);\n    for (std::size_t i = 1; i < states_.size(); ++i)\n    {\n        double d = si_->distance(states_[i], state);\n        if (d < min_d)\n        {\n            min_d = d;\n            index = i;\n        }\n    }\n    return index;\n}\n\nvoid ompl::geometric::PathGeometric::clear()\n{\n    freeMemory();\n    states_.clear();\n}\n"
        }
    ]
}